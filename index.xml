<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>a-simple-bolg on a-simple-bolg</title>
    <link>https://edte.github.io/</link>
    <description>Recent content in a-simple-bolg on a-simple-bolg</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jul 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>编写 go 语言时需要注意的那些规范</title>
      <link>https://edte.github.io/2020/2020-07-12-%E7%BC%96%E5%86%99-go-%E8%AF%AD%E8%A8%80%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-07-12-%E7%BC%96%E5%86%99-go-%E8%AF%AD%E8%A8%80%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E8%A7%84%E8%8C%83/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这篇文章将总结在编写 go 代码中常遇到的一些代码规范问题，本文只设计那些众多语言都会遇到的规范，不深入 go 语言的具体编写规范，如 go 的错误处理，并发处理等。&lt;/p&gt;

&lt;h2 id=&#34;标识符命名&#34;&gt;标识符命名&lt;/h2&gt;

&lt;p&gt;标识符的命名没有唯一的准则，在不同的语言中有着不同的规范，不同的团队也有着不同的规范。只要符合两个规则即可：模式化，易读。
最好的规范就是源码，标准库的规范是非常值得我们学习，可以查看我以前写的这篇文章 &lt;a href=&#34;https://edte.github.io/2020/2020-06-01-go-标识符命名指南/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go 标识符命名指南&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;

&lt;p&gt;良好的注释有利于理清自己的思路，同时也便于合作的伙伴阅读。同样可以看一下这篇文章 &lt;a href=&#34;https://edte.github.io/2020/2020-06-01-go-注释讲解/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go 注释讲解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;代码风格&#34;&gt;代码风格&lt;/h2&gt;

&lt;p&gt;在其他语言中有一些让我们难以选择的问题，如大括号的位置，空格的使用，缩进等等，在 go 中已经有一些硬性规定和现成的工具使用。
&lt;code&gt;go fmt&lt;/code&gt; 是 go 官方提供的一个工具，使用这个工具会自动格式化代码，我们规定代码都需要使用这个工具来格式化代码。
如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.package main
2.
3.import &amp;quot;fmt&amp;quot;
4.
5.func main() {
6.        fmt.Println(&amp;quot;hello world&amp;quot;)
7.    a := 1+   2
8.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;go fmt main.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.package main
2.
3.import &amp;quot;fmt&amp;quot;
4.
5.func main() {
6.    fmt.Println(&amp;quot;hello world&amp;quot;)
7.    a := 1 + 2
8.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Goland 中，可以使用 &lt;code&gt;Ctrl+Alt+L&lt;/code&gt; 快捷键格式化代码，可以养成在编写代码时经常格式化代码的习惯。&lt;/p&gt;

&lt;h2 id=&#34;行长&#34;&gt;行长&lt;/h2&gt;

&lt;p&gt;代码是怎样的风格，编译器并不知道，对代码风格进行规定是为了便于人阅读，而硬性规定则是保证团队不用在这个上面再花费时间。
对于行长来说，这就是一个比较客观的规定，在以前，python 和 linux 的源码都规定不能超过 80 字符，不过现在随着显示器的发展，这个要求没有那么死了，具体的长度可以看团队中大部分人使用多少尺寸的显示器，最好行长能够在显示器上直接显示，而无需移动屏幕。
对于规定来说，靠人来判断是低效率的行为，可以使用工具来统一，在 Goland 中，可以在 &lt;code&gt;settings-&amp;gt;editor-&amp;gt;code style&lt;/code&gt; 中修改代码行长。&lt;/p&gt;

&lt;h2 id=&#34;函数长度&#34;&gt;函数长度&lt;/h2&gt;

&lt;p&gt;类似于行长，一个函数的长度也是我们需要考虑的。在实际编码中，并不需要把函数长度这种东西硬性规定，但是我们应该有这个意识，代码长度最好在一个屏幕前就能看完，而不需要移动。
同时，我们也应该意识到，一个函数就应该只做函数名所规定的功能，如果函数过于冗长，或者你发现函数中开始加入了其他功能，你就应该考虑拆分函数了。&lt;/p&gt;

&lt;h2 id=&#34;导包&#34;&gt;导包&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;分组&lt;/strong&gt;
可以把导入的包分为两组，把标准库和其他库分开，标准库放在前面
这是 gin 项目 gin 文件，可以参考一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.import (
2.    &amp;quot;fmt&amp;quot;
3.    &amp;quot;html/template&amp;quot;
4.    &amp;quot;net&amp;quot;
5.    &amp;quot;net/http&amp;quot;
6.    &amp;quot;os&amp;quot;
7.    &amp;quot;path&amp;quot;
8.    &amp;quot;sync&amp;quot;
9.
10.    &amp;quot;github.com/gin-gonic/gin/internal/bytesconv&amp;quot;
11.    &amp;quot;github.com/gin-gonic/gin/render&amp;quot;
12.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者分为三类，从上到下分别为标准库，此项目，其他库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.import (
2.    &amp;quot;encoding/json&amp;quot;
3.    &amp;quot;strings&amp;quot;
4.
5.    &amp;quot;myproject/models&amp;quot;
6.    &amp;quot;myproject/controller&amp;quot;
7.    &amp;quot;myproject/utils&amp;quot;
8.
9.    &amp;quot;github.com/astaxie/beego&amp;quot;
10.    &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
11.)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Goland 中，在 &lt;code&gt;settings -&amp;gt; editor -&amp;gt; code style -&amp;gt; Go -&amp;gt; Imports&lt;/code&gt; 中可以修改默认导包情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;
导包不要使用相对路径，相对路径只是你的电脑的包路径，不具有迁移性，全使用绝对路径&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;别名&lt;/strong&gt;
如果包的名字和导入路径的最后一个元素不匹配，则需要使用别名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.import (
2.  &amp;quot;net/http&amp;quot;
3.
4.  client &amp;quot;example.com/client-go&amp;quot;
5.  trace &amp;quot;example.com/trace/v2&amp;quot;
6.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当包名冲突时，才使用别名，没有冲突则别使用别名，同时给包名起名时应避免和标准库重名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.import (
2.  &amp;quot;fmt&amp;quot;
3.  &amp;quot;os&amp;quot;
4.  &amp;quot;runtime/trace&amp;quot;
5.
6.  nettrace &amp;quot;golang.net/x/trace&amp;quot;
7.)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;相似声明&#34;&gt;相似声明&lt;/h2&gt;

&lt;p&gt;对变量，常量，类型的声明，应该把相似声明的声明放在一组，这样逻辑更加清晰，就像 import 包分开一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.const (
2.  a = 1
3.  b = 2
4.)
5.
6.var (
7.  a = 1
8.  b = 2
9.)
10.
11.type (
12.  Area float64
13.  Volume float64
14.)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数分组和顺序&#34;&gt;函数分组和顺序&lt;/h2&gt;

&lt;p&gt;在 go 中经常是这样生成函数的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.先生成一个类型，如 struct
2.然后生成一个类型的 constructor，即 New 函数
3.然后是这个类型的方法
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 go 中，涉及这种函数的使用时，应该按这个顺序来放代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.type something struct{ ... }
2.
3.func newSomething() *something {
4.    return &amp;amp;something{}
5.}
6.
7.func (s *something) Cost() {
8.  return calcCost(s.weights)
9.}
10.
11.func (s *something) Stop() {...}
12.
13.func calcCost(n []int) int {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码顺序&#34;&gt;代码顺序&lt;/h2&gt;

&lt;p&gt;上面讲了常见的函数顺序，现在来讲一下 go 文件的常见排序
先不说注释，一般是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.包名
2.导包  // 注意分组
3.需要在包中使用的变量，常量，类型，接口等  // 注意分组
4.然后设计类型方法的，按上面那样排序列出函数
5.一些普通的，但是需要放在这个文件里的函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如 gin 项目的 gin 文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;包名&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.package gin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.const defaultMultipartMemory = 32 &amp;lt;&amp;lt; 20 // 32 MB
2.
3.var (
4.    default404Body   = []byte(&amp;quot;404 page not found&amp;quot;)
5.    default405Body   = []byte(&amp;quot;405 method not allowed&amp;quot;)
6.    defaultAppEngine bool
7.)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;类型和方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.// HandlersChain defines a HandlerFunc array.
2.type HandlersChain []HandlerFunc
3.
4.// Last returns the last handler in the chain. ie. the last handler is the main one.
5.func (c HandlersChain) Last() HandlerFunc {
6.    if length := len(c); length &amp;gt; 0 {
7.        return c[length-1]
8.    }
9.    return nil
10.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;普通的函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.func redirectFixedPath(c *Context, root *node, trailingSlash bool) bool {
2.    req := c.Request
3.    rPath := req.URL.Path
4.
5.    if fixedPath, ok := root.findCaseInsensitivePath(cleanPath(rPath), trailingSlash); ok {
6.        req.URL.Path = bytesconv.BytesToString(fixedPath)
7.        redirectRequest(c)
8.        return true
9.    }
10.    return false
11.}
12.
13.func redirectRequest(c *Context) {
14.    req := c.Request
15.    rPath := req.URL.Path
16.    rURL := req.URL.String()
17.
18.    code := http.StatusMovedPermanently // Permanent redirect, request with GET method
19.    if req.Method != http.MethodGet {
20.        code = http.StatusTemporaryRedirect
21.    }
22.    debugPrint(&amp;quot;redirecting request %d: %s --&amp;gt; %s&amp;quot;, code, rPath, rURL)
23.    http.Redirect(c.Writer, req, rURL, code)
24.    c.writermem.WriteHeaderNow()
25.}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;单元测试&lt;/strong&gt;
我们有时会遇到一个笑话，测试人员对代码进行了多次测试，而用户出乎意料的操作却让程序崩溃了。作为开发人员，对代码进行测试也是需要掌握的基本技能。单元测试即对每个函数可能遇到的各种情况都进行测试，那么无论用户进行怎样的输入，程序都能够处理，这也就是我们常说的程序健壮性好。
在 go 中，官方提供了 &lt;code&gt;go test&lt;/code&gt; 工具用来单元测试，一般我们都是使用这个工具来进行单元测试。
单元测试有几点要求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.测试文件必须以 _test.go 结尾
2.测试函数必须以 Test 开头
3.测试函数参数必须是 t *testing.T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如 &lt;code&gt;add.go&lt;/code&gt; 文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.func Add(a int, b int) int {
2.    return a + b
3.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试文件 &lt;code&gt;add_test.go&lt;/code&gt; 中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.func TestAdd(t *testing.T) {
2.    fmt.Println(Add(1, 2))
3.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 go test 测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.$ go test add.go add_test.go 
2.ok      command-line-arguments  0.001s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到测试通过了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;性能测试&lt;/strong&gt;
单元测试是为了测试函数能否通过，而性能测试则是测试代码的性能。
比如我们有时候需要把 int 转换为 string，需要知道几种转换方法之间的效率，或者想知道遍历 map 和遍历 array 的效率区别，就可以使用性能测试。&lt;/p&gt;

&lt;p&gt;同样的，我们可以利用 &lt;code&gt;go test&lt;/code&gt; 工具进行性能测试
性能测试也有几点要求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.测试文件以 _test.go 结尾
2.测试函数以 Benchmark 开头
3.测试函数以 b *testing.B 为参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试文件 &lt;code&gt;itoa_test.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.func BenchmarkSprintf(b *testing.B){
2.    num:=10
3.    b.ResetTimer()
4.    for i:=0;i&amp;lt;b.N;i++{
5.        fmt.Sprintf(&amp;quot;%d&amp;quot;,num)
6.    }
7.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.$ go test itoa_test.go -bench=. -run=none
2.goos: linux
3.goarch: amd64
4.BenchmarkSprintf-6      15505934                75.6 ns/op
5.PASS
6.ok      command-line-arguments  1.254s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就能看到测试成功了，由于我们这里只是为了说明 go 中测试文件的使用和存在，所以就不展开讲了，需要具体学习可以参考其他书籍。&lt;/p&gt;

&lt;h2 id=&#34;项目目录&#34;&gt;项目目录&lt;/h2&gt;

&lt;p&gt;编写一个项目时，怎么管理项目的目录也是非常重要的一点。良好的项目目录表明这个项目架构清晰，在 debug 时，项目结构清晰，很容易就能找到 bug 的所在，同时在阅读代码时，良好的项目目录也能便于我们阅读。
一般我们使用 go 语言都是编写 web 项目，所以只需要参考那些 web 项目是怎么组织项目的即可。一般的 web 项目（后端）使用分层架构，如 MVC，MVP，MVVM 架构等
如果是个人开发小型项目的话，没有在编写代码前规划好项目结构，就只能不断的重构才能有一个好的项目结构。所以如果项目结构有问题，也没有什么，多参考那些优秀代码的项目目录，阅读那些总结好的项目结构，如 &lt;a href=&#34;https://github.com/golang-standards/project-layout&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;project-layout&lt;/a&gt;， 再不断的重构。
当然，最好是在编写代码前就已经设计好项目结构，这样是最好的。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文总结了一些在编写高级语言中都常会遇到的问题，如标识符命名，注释，项目目录等问题，这篇文章并不是指南，不要求完全按照上面的来做，同时有许多点也没有展开来讲。重要的是希望你能注意到这些问题，而具体的操作可以直接查看标准库源码，优秀库源码，或者参考那些大公司的规范。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://learnku.com/docs/effective-go/2020&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;高效的 Go 编程 Effective Go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://studygolang.com/articles/2059&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Go 编码规范指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[&lt;a href=&#34;https://zhuanlan.zhihu.com/p/63250689#三、代码风格&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;代码规范] Go 语言编码规范指导&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/CodeReviewComments#comment-sentences&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CodeReviewComments&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/xxjwxc/uber_go_guide_cn#顶层变量声明&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Uber Go 语言编码规范&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/llitfkitfk/go-best-practice#6-api-设计&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Go 语言实战：编写可维护 Go 语言代码建议&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Unknwon/go-code-convention/blob/master/zh-CN/README.md&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;编码规范&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://objcoding.com/2018/09/14/go-test/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go test 单元测试&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/124198314&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Go 项目组织实践&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么你的程序总是 stack overflow?</title>
      <link>https://edte.github.io/2020/2020-07-10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%80%BB%E6%98%AF-stack-overflow/</link>
      <pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-07-10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%80%BB%E6%98%AF-stack-overflow/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在刷 leetcode 时，遇到了 stack-buffer-overflow, 这个问题比较常见，干脆总结一下原因。本文是在 linux 下操作的，需要使用一些相关的命令。&lt;/p&gt;

&lt;h2 id=&#34;stack-是什么&#34;&gt;stack 是什么&lt;/h2&gt;

&lt;p&gt;一般 stack 这个词有两个意思，即 stack 这种数据结构，和虚拟内存中 stack   这个段。&lt;/p&gt;

&lt;p&gt;为什么虚拟内存中 stack 段会叫这个名字，我们先来看一下 stack 这种数据结构。stack 是线性表中的一种，元素间一对一，而且只能从 stack top 增加或删除元素，遵循 LIFO(last in, fisrt out) 原则。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200711161907944-940856376.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图，在 stack top 入 stack（push），出 stack(pop)。 LIFO 原则就是先入栈的，后出栈，看图就容易理解&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200711162109707-737108200.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一个入栈的元素 1, 需要其他元素的出栈后才能出栈，而最后一个进栈的元素 4, 则第一个出栈。stack 在日常生活中也非常常见，如平放一些书，就是一个典型的 stack 结构。&lt;/p&gt;

&lt;p&gt;stack 是一种逻辑结构，主要讲求的是元素间的逻辑关系，具体的实现可以顺序存储，或者链式存储，这里就不展开了。&lt;/p&gt;

&lt;h2 id=&#34;进程空间-进程内存结构&#34;&gt;进程空间/进程内存结构&lt;/h2&gt;

&lt;p&gt;我们首先需要知道程序是怎么从源码到执行的。c 语言需要进过这几个过程，编写源码 -&amp;gt; 预处理 -&amp;gt; 编译 -&amp;gt; 链接 成二进制文件，在 linux 下即 elf 文件，可以是可执行文件，或者是库文件。&lt;/p&gt;

&lt;p&gt;如果是可执行文件，链接完成后，需要装载到内存中，操作系统给这个程序分配一定的内存空间，然后程序变成进程就开始执行了。&lt;/p&gt;

&lt;p&gt;操作系统给程序分配的空间，这块内存有固定的结构，如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wongxingjun.github.io/figures/c-memory-layout/memorylayout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一段是这块内存的一些上下文信息，如地址，环境变量等。&lt;/p&gt;

&lt;p&gt;剩余的几段是我们需要掌握的，即 stack, heap, BSS, data, text&lt;/p&gt;

&lt;p&gt;text 段是存代码，字面量，在运行时只读&lt;/p&gt;

&lt;p&gt;data 段存已经初始化的静态变量，全局变量&lt;/p&gt;

&lt;p&gt;BSS 段存没有初始化的静态变量，全局变量&lt;/p&gt;

&lt;p&gt;heap 段存程序员自己分配的变量&lt;/p&gt;

&lt;p&gt;stack 段存操作系统分配的局部变量，如参数，返回值等&lt;/p&gt;

&lt;p&gt;BSS/data 段即一般说的静态区，全局区等。&lt;/p&gt;

&lt;h2 id=&#34;代码组成&#34;&gt;代码组成&lt;/h2&gt;

&lt;p&gt;代码是由语句，变量，常量，字面量组成的。&lt;/p&gt;

&lt;p&gt;语句即关键字/标识符等，字面量则是变量或常量的值，值整数 1,字符串 &amp;ldquo;hello&amp;rdquo; 等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) {
    int a = 1;
    char c[] = {&amp;quot;hello&amp;quot;};
    printf(&amp;quot;%d, %s\n&amp;quot;, a, c);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
main()
printf
return
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;程序内存分配方式&#34;&gt;程序内存分配方式&lt;/h2&gt;

&lt;p&gt;有了上面基础知识后，后面的知识更容易理解。现在我们举实例来说明&lt;/p&gt;

&lt;p&gt;我们先来编写个最第一个程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) {
	
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 gcc 编译, gcc 是一个常用的 c 编译器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o main main.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到可执行文件 main，可以执行一下试试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./main 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们使用 &lt;code&gt;size&lt;/code&gt; 命令，man 是这样解释这个命令的 &lt;code&gt;list section sizes and total size of binary files&lt;/code&gt;，我们可以看到二进制文件的结构，装载到内存中运行时，也是根据此来分配内存的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ size main
   text    data     bss     dec     hex filename
   1282     512       8    1802     70a main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dec 是十进制（Decimal），hex 是十六进制，dec 即文件大小，hex 是对应的十六进制，filename 是文件名，这三个都不是我们需要关注的。&lt;/p&gt;

&lt;p&gt;我们可以看到 text，data，bss 这三段，现在我们的程序还没有运行，所以这三段编译结束后就已经固定了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;text&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;text 段是代码段，这段用来存语句和字面量的。&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) {
    int a = 1;
    char c[] = {&amp;quot;hello&amp;quot;};
    printf(&amp;quot;%d, %s\n&amp;quot;, a, c);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
main()
=
printf
return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等语句就是存在 text 区的，而&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
&amp;quot;hellow&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等字面量也是存在 text 区的。这个区不是我们想说的重点，继续。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;data/bss&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们加几个未初始化的全局变量试试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int a;
int b;

int main(void) {

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ size main
   text    data     bss     dec     hex filename
   1282     512      16    1810     712 main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 BSS 段增加了，现在我们再试试加几个已经初始化的全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int a = 1;
int b = 2;

int main(void) {

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ size main
   text    data     bss     dec     hex filename
   1282     520       8    1810     712 main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 data 段增加了&lt;/p&gt;

&lt;p&gt;现在我们再加几个没有初始化的静态变量试试（局部/全局都一样）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) {
    static int a;
    static int b;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

static int a;
static int b;

int main(void) {

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ size main
   text    data     bss     dec     hex filename
   1282     512      16    1810     712 main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 BSS 段增加了&lt;/p&gt;

&lt;p&gt;现在我们再加几个已经初始化的静态变量试试（局部/全局都一样）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) {
    static int a = 1;
    static int b = 2;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

static int a = 1;
static int b = 2;

int main(void) {

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ size main
   text    data     bss     dec     hex filename
   1282     520       8    1810     712 main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，data 段增加了。&lt;/p&gt;

&lt;p&gt;通过上面的分析，我们发现未初始化的全局变量，未初始化的静态变量存在 bss 段，而已经初始化的全局变量，已经初始化的静态变量存在 data 段。&lt;/p&gt;

&lt;p&gt;存在 data/bss 两段的变量，一般就叫静态内存分配，所谓静态就是编译前就已经分配好了内存，这我们从上面也可以得知。&lt;/p&gt;

&lt;p&gt;除了这两种变量，还有 const 修饰的变量，register 修饰的变量等，但这都不是我们现在要讨论的重点，这里就不展开了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;heap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在上面讨论的 bss/data 区的变量，即静态分配的变量，在编译前就分配好了内存，程序结束才释放，所以在程序允许过程中，这些内存里的数据是不会丢失的。所以我们可以把这些变量作为返回值，赋给调用的函数里的变量。或者我们多次调用同一个函数中声明的静态分配的变量，值是接着上一次调用的值的。&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int StaticAlloc() {
    static int a = 123;
    return a;
}

int main(void) {
    printf(&amp;quot;%d&amp;quot;, StaticAlloc());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里成调用值成功了，同样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void StaticAlloc() {
    static int a = 123;
    a++;
    printf(&amp;quot;%d\n&amp;quot;, a);
}

int main(void) {
    StaticAlloc();
    StaticAlloc();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这里没看懂函数调用的原理，可以先看下面 stack 的部分，再重新看。&lt;/p&gt;

&lt;p&gt;类似静态分配变量的生命期是整个程序，还有一种变量也是这样。&lt;/p&gt;

&lt;p&gt;再来看一下内存结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wongxingjun.github.io/figures/c-memory-layout/memorylayout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;bss 区上面有一个 heap 区，我们使用 size 命令时没有看到这个区，这是因为这个区和 stack 区一样，是在程序装载到内存中，开始运行后才分配的。图里的箭头就是这个意思。&lt;/p&gt;

&lt;p&gt;heap 这个区和 stack 区一样，程序会分配一个最大的内存限制，具体的值要看不同的操作系统。而在程序中实际使用了对于的变量，就是分配对应大小的值。在图中就是 heap 向上扩张，而 stack 向下扩张。&lt;/p&gt;

&lt;p&gt;普通的大小，能查看到返回的地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(void) {
    int *a = (int *) malloc(4);
    printf(&amp;quot;%p\n&amp;quot;, a); // 0x5626852372a0

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分配的内存过大，操作 heap 的最大值，所以没有分配内存成功，直接返回 nil 了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(void) {
    int *a = (int *) malloc(9999999999999999);
    printf(&amp;quot;%p\n&amp;quot;, a); // nil

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 c 语言中，要在 heap 中分配内存，需要使用 stdlib.c 库中的 &lt;code&gt;malloc&lt;/code&gt; 函数，传入分配的大小，返回那块内存的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int main(void) {
    int *a = (int *) malloc(sizeof(int));

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如这个代码就是传了 int 占据的 byte 大小，然后分配这么多内存，再返回首地址，转换为 int 指针。这就是在 heap 上分配的，然后如果不释放这块内存的话，在程序结束前，这块内存都会被操作系统认为你在使用，但是实际上你没用，所以这块内存就会被浪费，这就是内存泄漏。释放的函数是 free。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int DynamicAlloc() {
    int *a = (int *) malloc(sizeof(int));
    *a = 123;
    return *a;
}

int main(void) {
    printf(&amp;quot;%d\n&amp;quot;, DynamicAlloc()); // 123

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在子函数中分配 heap内存，即使子函数结束了，里面分配的 heap 内存还在，数据也在。要释放的话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int DynamicAlloc() {
    int *a = (int *) malloc(sizeof(int));
    *a = 123;
    free(a);
    return *a;
}

int main(void) {
    printf(&amp;quot;%p\n&amp;quot;, DynamicAlloc()); // nil

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;释放后，哪块内存就不能用了，就变成了 nil。&lt;/p&gt;

&lt;p&gt;从上面我们可以发现，heap 是运行期间自己分配的内存，需要自己释放，不然的话就不会释放。这种分配在 heap 上的方式就叫动态内存分配。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看了上面的你可能还是有些不理解 heap 和静态分配变量，那种子函数调用后返回地址，内存还能够使用，这种性质。现在我们继续来看 stack ，对比着你就能明白了。&lt;/p&gt;

&lt;p&gt;继续来看内存结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wongxingjun.github.io/figures/c-memory-layout/memorylayout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;stack 和 heap 一样，在程序运行时才分配内存，运行后可以在 &lt;code&gt;/proc&lt;/code&gt; 目录对应进程文件查看，stack 同样有一个 os 分配的最大值，具体分配多少，需要看实际的代码。&lt;/p&gt;

&lt;p&gt;stack 这个区域用来存 auto 变量，也就是局部作用域的变量，是我们平时使用最多的变量，包括形参，返回值，函数中的局部变量等。&lt;/p&gt;

&lt;p&gt;我们知道 c 是由需要函数组成的，而局部变量也是按照函数来划分的，那么在 stack 中，又是怎么划分区域来存局部变量的呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;下面的知识可能有一些错误，我没有深入到汇编，查看寄存器的使用情况，这里只是为了解释 stack 的分配问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编译器会计算一个函数中局部变量的个数和大小，然后分配一定的内存空间作为一帧。函数名就是在一帧的入口地址，调用函数的时候，就会跳转到这一帧然后使用这一帧里的内存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200711224339366-1327310732.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先是返回值入 stack，然后是普通的局部变量，最后是行参。按照我们上面讲解 stack 这种数据结构，这里的 stack 区域也是这种性质，所以行参先出 stack，然后是普通的局部变量，最后是返回值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200711224527926-1075323475.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当返回值出 stack 后，这个函数就调用结束了，然后返回到调用函数的地址，继续执行，而这个函数分配的一帧地址就被操作系统回收了。&lt;/p&gt;

&lt;p&gt;所以在函数中分配的局部变量，然后返回这个变量的地址，而在其他函数中是无法使用这块地址的内存的，因为它已经被释放了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int *AutoAlloc() {
    int a[] = {1, 2, 3};
    
    return a;
}

int main(void) {
    printf(&amp;quot;%p&amp;quot;, AutoAlloc()); // nil

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如这个函数中，在 AutoAlloc 函数中分配的数组，存了 1，2, 3，然后把首地址作为返回值，在 main 中打印这个地址时，这个地址却变成了 nil，这就是因为 AutoAlloc 分配的 stack 区域已经释放了。&lt;/p&gt;

&lt;p&gt;这种分配在 stack 上的方式也被称为自动分配方式，也就是 auto，即局部变量分配。&lt;/p&gt;

&lt;h2 id=&#34;再谈-stack-overflow&#34;&gt;再谈 stack overflow&lt;/h2&gt;

&lt;p&gt;经过上面的分析，我想现在 stack 溢出这个问题已经很明显了，就是 stack 已经满了，而还要分配。如无限递归&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void AutoAlloc() {
    AutoAlloc();
}

int main(void) {
    AutoAlloc();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数就一直调用 AutoAlloc，就一直在 stack 区分配内存，最后 stack 区满了，就溢出了。&lt;/p&gt;

&lt;p&gt;除了无限递归的问题外，使用已经释放的内存也是常遇到的问题，如在 leetcode 上刷数据结构时，有的题会需要你返回一个数组，然后数组中存数据。如果你在函数中用的 array 来存数组，而返回 array 的首地址的话，那么对方得到的地址就是 nil，就会报错，这时候使用 heap 来存数据更合适。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我们经过分析内存结构，代码组成，然后引入变量的常用内存分配方式，从底层说明了 stack 溢出的原理。&lt;/p&gt;

&lt;p&gt;从这个过程中，我也遇到许多问题，如内存结构，c 的汇编实现等底层知识，这再一次让我意识到底层知识的重要性。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/8385322/difference-between-static-memory-allocation-and-dynamic-memory-allocation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Difference between static memory allocation and dynamic memory allocation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-cn/%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F#cite_note-5&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;自动变量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.lagou.com/lgeduarticle/49533.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;函数内存分配&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ivanzz1001.github.io/records/post/cplusplus/2018/11/12/cpluscplus-segment&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;数据段、代码段、堆栈段、BSS 段的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/feng9exe/p/12527408.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;函数的返回值保存在内存的什么区域&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/shine-lee/p/4316219.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;实例分析 C 程序运行时的内存结构&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>图解队列</title>
      <link>https://edte.github.io/2020/2020-07-08-%E5%9B%BE%E8%A7%A3%E9%98%9F%E5%88%97/</link>
      <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-07-08-%E5%9B%BE%E8%A7%A3%E9%98%9F%E5%88%97/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;这篇文章是根据我学习 queue 的学习笔记总结而成的。&lt;/p&gt;

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;queue 是线性表(linear list)中的一种，元素间遵循一对一的原则。&lt;/p&gt;

&lt;p&gt;除此外，queue 遵循 FIFO(first in first out) 原则，即先进的元素先出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708144435829-1190638552.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;

&lt;p&gt;queue 入队和出队方式分为单端队列和双端队列，一般我们说队列都指的是单端队列。&lt;/p&gt;

&lt;p&gt;单端队列就是只能在队尾（rear) 入队，只能在队首(front)出队的队列&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708144611569-1301444973.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双端队列则是队首和队尾都可以入队和出队的队列。(deque)(double-ended queue)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708171600292-815729097.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;queue 按照入出队元素的选择方式分为普通队列的和优先队列。&lt;/p&gt;

&lt;p&gt;普通的队列就是按顺序入出队，入队到队尾，把队首出队。&lt;/p&gt;

&lt;p&gt;而优先队列则要看优先级，优先级是自己定的，每个元素都有其优先级，而入出队则选择最大或最小优先级的元素来操作。&lt;/p&gt;

&lt;p&gt;优先队列分为有序的和无序的，如果优先级是指最大值，每次出队都是取出最大值。那么就分为两类，入队时不排序，直接存在队尾，而出队时则需要搜索，取出最大值，这样入队时间复杂度为 O(1), 而出队的时间复杂度为 O(n), 类似的，如果是入队时排序，那么在入队时就要插入到对应位置，而出队时则直接出队首的位置，入队的时间复杂度为 O(n), 出队为 O(1), 这其中还设计搜索算法和排序算法。&lt;/p&gt;

&lt;p&gt;没有特别说明是双端队列和或优先队列时，都是默认的指单端普通队列。&lt;/p&gt;

&lt;p&gt;应用的比较广的单端普通队列，也是我们生活中比较常见的，如实际生活中的排队，不考虑插队这种情况的话，也是队尾入队，队首出队，你可以观察一下生活中遇到的队伍是不是这样。&lt;/p&gt;

&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;

&lt;p&gt;queue 可以用 顺序存储 或 链式存储实现。
无论哪种方式都需要用两个指针，front 和 rear 指向 queue 首和 queue 尾&lt;/p&gt;

&lt;h3 id=&#34;顺序存储&#34;&gt;顺序存储&lt;/h3&gt;

&lt;p&gt;首先定义 queue，需要两指针和数据域&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200707202839305-403164183.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 分配的内存大小
#define SIZE 5

// 定义 queue
typedef struct {
    int data[SIZE];  //数据
    int front;       // 首指针
    int rear;        //尾指针
} Queue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后初始化，两指针同时指向 array[0] 处，因为 0 处是初始位置比较容易管理
&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150521008-1021086627.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 初始化 queue
Queue CreateQueue() {
    Queue queue;
    queue.rear = 0;
    queue.front = 0;
    return queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在问题来了， 0 处设置为 队首还是队尾呢？从技术上来说，肯定都是能够实现的，但是问题是，哪个更适合呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0 处为队首&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们假设 0 处是队首, 只能从队尾入队，从队首出队
假设队伍现在是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150521008-1021086627.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们发现现在的尾指针指向的值是空的，也就是说，尾指针其实指向的是实际队尾的下一个&lt;/p&gt;

&lt;p&gt;那么要入队，队列又只能从队尾入队，所以直接给尾指针指向的赋值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150441148-963502923.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后尾指针需要向后移动一次&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150417990-1323935408.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;转换为代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 入队
void EnQueue(Queue *queue, int data) {
    // 先尾指针赋值
    queue-&amp;gt;data[queue-&amp;gt;rear] = data;
    // 再尾指针移动
    queue-&amp;gt;rear++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意如果 queue 已经满了，入队会 overflow，所以还需要先判断是不是满了&lt;/p&gt;

&lt;p&gt;问题是怎么判断是不错满了呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708151310997-1151621032.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 array 中，满了的意思是分配的内存不能再给 queue 用了，所以就是 rear 指向分配内存的边缘了，所以只需要判断 rear 是不是等于 SIZE 即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 入队
void EnQueue(Queue *queue, int data) {
    // 判断是否 overflow
    if (queue-&amp;gt;rear == SIZE) {
        return;
    }

    // 先尾指针赋值
    queue-&amp;gt;data[queue-&amp;gt;rear] = data;
    // 再尾指针移动
    queue-&amp;gt;rear++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;出队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在假设 queue 是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150417990-1323935408.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要出队的话，只需要首指针向右移动一次即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708151940172-1933758519.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可能有人会问，那出队的那个内存的值怎么办呢？&lt;/p&gt;

&lt;p&gt;一般 queue 作为局部变量的话，用 array 来实现，都是分配在 stack 上的，调用函数时系统自动分配，函数结束自动回收。而一般分配后，也不会清空，刚分配的内存存的值也是不能确定的脏值。并且，我们操作 queue 只看的是 front 和 rear 中间的部分，所以那个值没有改变的必要。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708152253839-684771514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用代码来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队
void DeQueue(Queue *queue) {
    // 首指针移动
    queue-&amp;gt;front++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，不要忘记判断边界条件，如果已经是空 queue 的话，再出队会 underflow，所以还需要判断是否为空。&lt;/p&gt;

&lt;p&gt;要判断是否为空比较容易理解，只需判断 front 是否等于 rear 即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空
    if (queue-&amp;gt;rear == queue-&amp;gt;front) {
        return;
    }
    // 首指针移动
    queue-&amp;gt;front++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取队伍长度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要获取队伍长度的话，只需要得到 rear 和 front 间的长度即可，也不用判断是否为空，为空是长度为 0&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708152750861-282212745.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 获取 queue 长度
int Len(Queue *queue) {
    return queue-&amp;gt;rear - queue-&amp;gt;front;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;0 处为队尾&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们假设队伍是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708153243726-1777482134.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;入队的话，需要在 rear 处入队，而 rear 在 0 处，左边又没有地方，所以只能往右边存，现在右边又没有空，所以需要右边留一个空出来。这样的话，就需要右边每个值都向右移动一个位置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708153615573-1235449861.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后 rear 向左移动&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708153715053-606461553.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再赋值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708153749303-661618685.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现如果把 0 作为队尾，入队的话，时间复杂度是 O(n), 而把 0 作为队首则都是 O(1), 同样的，按照一般的习惯，队尾一般都比队首大，可是把 0 作为队尾则反过来了，不符合我们的习惯。所以一般还是把 0 处作为队首比较好。&lt;/p&gt;

&lt;p&gt;当然有人可能会问，分配一块内存，然后直接在中间某处作为队首队尾如何&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708154123074-527878191.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样的话，无论往哪边排队，都是可以的，不过一般我们没有这样做而已。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实际操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们来实际看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#define SIZE 5

typedef struct {
    int data[SIZE];
    int front;
    int rear;
} Queue;

Queue CreateQueue() {
    Queue queue;
    queue.rear = 0;
    queue.front = 0;
    return queue;
}

// 入队
void EnQueue(Queue *queue, int data) {
    // 判断是否 overflow
    if (queue-&amp;gt;rear == SIZE) {
        return;
    }

    // 先尾指针赋值
    queue-&amp;gt;data[queue-&amp;gt;rear] = data;
    // 再尾指针移动
    queue-&amp;gt;rear++;
}

// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空
    if (queue-&amp;gt;rear == queue-&amp;gt;front) {
        return;
    }
    // 尾指针移动
    queue-&amp;gt;front++;
}

// 获取 queue 长度
int Len(Queue *queue) {
    return queue-&amp;gt;rear - queue-&amp;gt;front;
}

void TraverseQueue(Queue queue) {
    while (queue.front != queue.rear) {
        printf(&amp;quot;%d\n&amp;quot;, queue.data[queue.front]);
        queue.front++;
    }
}

int main(void) {
    Queue queue = CreateQueue();
    EnQueue(&amp;amp;queue, 1);
    EnQueue(&amp;amp;queue, 2);
    EnQueue(&amp;amp;queue, 3);
    EnQueue(&amp;amp;queue, 4);
    EnQueue(&amp;amp;queue, 5);

    TraverseQueue(queue);

    DeQueue(&amp;amp;queue);

    TraverseQueue(queue);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;循环队列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们现在再来看一下上面，刚开始时队列是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150521008-1021086627.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后入队一次，出队一次，变成了这样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708152253839-684771514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;发现没有，队列在往右移动，其实容易理解，入队和出队都是指针往右动，那么队列总体在往右移动也正常，但是左边的那些内存空间呢？&lt;/p&gt;

&lt;p&gt;我们会发现随着队列的移动，左边的空间被浪费了，而且越来越多。那么有什么办法重新利用起左边的那些空间吗？&lt;/p&gt;

&lt;p&gt;既然队列在往右移动，那么只要往右移动到边界后，又重新移动到左边就行了，这就是一个周期函数，自变量是往右移动的长度，因变量是实际队列的长度&lt;/p&gt;

&lt;p&gt;对于用 array 来实现的普通 queue，定义 queue 和初始化都是相同的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 分配的内存大小
#define SIZE 5

// 定义 queue
typedef struct {
    int data[SIZE];  //数据
    int front;       // 首指针
    int rear;        //尾指针
} Queue;

// 初始化 queue
Queue CreateQueue() {
    Queue queue;
    queue.rear = 0;
    queue.front = 0;
    return queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以问题在于，入队和出队&lt;/p&gt;

&lt;p&gt;用 array 来实现 queue 时，指针的移动是按下标来实现的，所以只需要指针到达 queue 右边边界后，又等于左边边界下标即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同样的，入队时首先给 rear 指向的赋值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150521008-1021086627.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150441148-963502923.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后 rear 移动，当不是循环时，直接向右移动即可，现在循环就不行了。需要先移动，然后对 SIZE 取余数，至于为什么，我们来分析一下&lt;/p&gt;

&lt;p&gt;当 rear 没有超过 SIZE 时，移动后取余，还是本身，就等于直接向右移动&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150417990-1323935408.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当 rear 超过 SIZE 后&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708160824609-220481517.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再取余，取整就是圈数，取余就是余下的位置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708160947821-1436455382.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用代码实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 入队
void EnQueue(Queue *queue, int data) {
    // 先尾指针赋值
    queue-&amp;gt;data[queue-&amp;gt;rear] = data;
    // 再尾指针移动
    queue-&amp;gt;rear = (queue-&amp;gt;rear + 1) % SIZE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，要注意是否 queue 满了，比较尾指针移动后的位置，和 front 的大小&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 入队
void EnQueue(Queue *queue, int data) {
    // 判断是否满 queue 
    if (queue-&amp;gt;front == (queue-&amp;gt;front + 1) % SIZE) {
        return;
    }

    // 先尾指针赋值
    queue-&amp;gt;data[queue-&amp;gt;rear] = data;
    // 再尾指针移动
    queue-&amp;gt;rear = (queue-&amp;gt;rear + 1) % SIZE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;出队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设队伍现在是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708161740553-328181925.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，出队的话，需要 front 向前移动，不过是环上的移动，需要加 1 后取余&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队
void DeQueue(Queue *queue) {
    // 尾指针移动
    queue-&amp;gt;front = (queue-&amp;gt;front + 1) % SIZE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后要需要是否为空，当为空时，front 等于 rear，直接判断即可，不用移动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空
    if (queue-&amp;gt;rear == queue-&amp;gt;front) {
        return;
    }
    // 尾指针移动
    queue-&amp;gt;front = (queue-&amp;gt;front + 1) % SIZE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;获取长度&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 获取 queue 长度
int Len(Queue queue) {
    return (queue.rear - queue.front + SIZE) % SIZE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;实际操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们来实际看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#define SIZE 5

typedef struct {
    int data[SIZE];
    int front;
    int rear;
} Queue;

Queue CreateQueue() {
    Queue queue;
    queue.rear = 0;
    queue.front = 0;
    return queue;
}

// 入队
void EnQueue(Queue *queue, int data) {
    // 判断是否满 queue
    if (queue-&amp;gt;front == (queue-&amp;gt;rear + 1) % SIZE) {
        return;
    }

    // 先尾指针赋值
    queue-&amp;gt;data[queue-&amp;gt;rear] = data;
    // 再尾指针移动
    queue-&amp;gt;rear = (queue-&amp;gt;rear + 1) % SIZE;
}

// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空
    if (queue-&amp;gt;rear == queue-&amp;gt;front) {
        return;
    }
    // 尾指针移动
    queue-&amp;gt;front = (queue-&amp;gt;front + 1) % SIZE;
}

// 获取 queue 长度
int Len(Queue queue) {
    return (queue.rear - queue.front + SIZE) % SIZE;
}

// 遍历 queue
void TraverseQueue(Queue queue) {
    while (queue.front != queue.rear) {
        printf(&amp;quot;%d\n&amp;quot;, queue.data[queue.front]);
        queue.front++;
    }
}

int main(void) {
    Queue queue = CreateQueue();
    EnQueue(&amp;amp;queue, 1);
    EnQueue(&amp;amp;queue, 2);
    EnQueue(&amp;amp;queue, 3);
    EnQueue(&amp;amp;queue, 4);
    EnQueue(&amp;amp;queue, 5);

    TraverseQueue(queue);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们这时会发现一个问题，明明我们分配了 5 个空间，然后存 5 个值，怎么只得到了 4 个值呢？&lt;/p&gt;

&lt;p&gt;我们来实际分析一下，假设已经存到第 3 个值了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708164915438-518134593.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后入队，queue-&amp;gt;front = 0, (queue-&amp;gt;rear + 1) % SIZE = 4,没有满，继续&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708164736517-675345207.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708164950574-788753523.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在已经入了 4 个值，再继续入队，queue-&amp;gt;front = 0, (queue-&amp;gt;rear + 1) % SIZE = 0, 我们发现 front == (rear+1)%SIZE 了，从位置上来说 rear 和 front 的确已经相邻，判断没有出问题，但是实际上 rear 指向的那个值并没有存东西&lt;/p&gt;

&lt;p&gt;我们现在回想一下最初初始化 queue 的时候&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150521008-1021086627.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现 rear 指向的值也没有值，而每次入队后，rear 指向的都是 queue 实际队尾的后面那个位置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708150417990-1323935408.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以循环队列总会浪费一个空间。&lt;/p&gt;

&lt;h3 id=&#34;链式存储&#34;&gt;链式存储&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从上面的分析可以发现，顺序存储的单端普通队列有着顺序存储的缺点，即容量固定，当队列容量不定时，链式存储能发挥它的优势。&lt;/p&gt;

&lt;p&gt;链式存储，是由每个 node 连接而成的，所以我们先来定义 node&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708222953404-1006557160.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个 node 需要存数据 data，和下一个 node 的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 队伍每个节点
typedef struct {
    int data;
    struct Node *next;
} Node;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后队列不同于普通的单链表，除了在元素的增删上有区别外，链式存储的队列还需要存两个地址，即 front 和 rear，而单链表只需要存首地址 head 即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708223501744-1390673518.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// queue
typedef struct {
    Node *front;
    Node *rear;
} Queue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如同单链表可以增加一个首节点，链队列也可以选择增加首节点。&lt;/p&gt;

&lt;p&gt;有头节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708223751553-75757813.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;无头节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708223911313-402115255.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;单端队列出队都是在 rear 处，有没有头节点对于出队而言没有什么影响。&lt;/p&gt;

&lt;p&gt;但是对于入队来说，没有头节点需要同时修改 front 和 rear，而有头节点直接修改 front 即可，除此外，初始化 queue，遍历 queue 都有一些区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果没有头节点的话，直接给两指针分配空间&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708224445372-1809678568.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后都指向 NULL 即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708223911313-402115255.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// init queue
Queue CreateQueue() {
    // 分配给 Queue 存两个指针的内存
    Queue *queue = (Queue *) malloc(sizeof(Queue));
    // 两指针指向 NULL
    queue-&amp;gt;rear = NULL;
    queue-&amp;gt;front = NULL;

    return *queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果有头节点的话，则除了需要给指针分配空间，还要分配一个新节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708224812447-1188455544.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后新节点指向 NULL&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708224901961-1624216339.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再指针指向这个节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708224933688-133770078.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 初始化队伍
Queue CreateQueue() {
    // 分配给 Queue 存两个指针的内存
    Queue *queue = (Queue *) malloc(sizeof(Queue));
    // 分配首节点
    Node *new_node = (Node *) malloc(sizeof(Node));
    // 首节点下一个指向 NULL
    new_node-&amp;gt;next = NULL;
    // queue 两指针指向首节点
    queue-&amp;gt;front = new_node;
    queue-&amp;gt;rear = new_node;

    return *queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果有头节点，需要先新建一个 node&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225150132-855963295.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;存值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225219472-682960157.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;新 node 指向 NULL，因为新 node 会变成队尾，而队尾是指向 NULL 的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225318213-1206582764.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后尾节点指向新节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225438233-236457312.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再尾指针指向新节点，即新的尾节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225527742-1785401901.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;换为代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 入队
void EnQueue(Queue *queue, int data) {
    // 建立新 node
    Node *new_node = (Node *) malloc(sizeof(Node));
    // 存值
    new_node-&amp;gt;data = data;
    // 新 node 对成为队尾，队尾指向 NULL
    new_node-&amp;gt;next = NULL;
    // 尾节点连接新 node
    queue-&amp;gt;rear-&amp;gt;next = (struct Node *) new_node;
    // 尾指针指向新 node
    queue-&amp;gt;rear = new_node;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是有首节点的入队方式，如果没有首节点的话，第一次入队有些不同&lt;/p&gt;

&lt;p&gt;这是初始化后的样子&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225744480-840269648.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后判断 queue 是第一次入队后，即判断 front 和 rear 都等于 NULL 后&lt;/p&gt;

&lt;p&gt;新建 node&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225914798-2026367134.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;新 node 存值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708225946852-354864368.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;新 node 连接 NULL&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708230020809-1551393815.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后两指针都指向新 node&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708230121592-1900847672.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这之后就和普通的入队方式没有什么区别了&lt;/p&gt;

&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 入队
void EnQueue(Queue *queue, int data) {
    // 建立新 node
    Node *new_node = (Node *) malloc(sizeof(Node));
    // 存值
    new_node-&amp;gt;data = data;
    // 新 node 对成为队尾，队尾指向 NULL
    new_node-&amp;gt;next = NULL;

    // 如果是没有头节点，且第一次入队
    if (queue-&amp;gt;rear == NULL &amp;amp;&amp;amp; queue-&amp;gt;front == NULL) {
        queue-&amp;gt;rear = new_node;
        queue-&amp;gt;front = new_node;
        return;
    }

    // 尾节点连接新 node
    queue-&amp;gt;rear-&amp;gt;next = (struct Node *) new_node;
    // 尾指针指向新 node
    queue-&amp;gt;rear = new_node;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;出队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;入队时没有容量限制，但是出队要注意是否为空队，所以我们都需要先判断一下是否为空队。&lt;/p&gt;

&lt;p&gt;而无论是有头节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708223751553-75757813.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;还是没有头节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708223911313-402115255.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;都只需判断 front 是否等于 rear 即可。&lt;/p&gt;

&lt;p&gt;我们继续来先看有头节点的出队&lt;/p&gt;

&lt;p&gt;现在假设队伍是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708230616661-1506848369.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;出队是出队首，但是有头节点的话，应该是头节点下一个节点，即这个&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708231147381-1529266212.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为是链式存储，我们需要自己释放内存，所以先备份要出的那个节点&lt;/p&gt;

&lt;p&gt;建立一个指针，然后指向这个节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708231336905-1096854923.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后头节点指向队首节点的下一个&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708231607493-33719760.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后释放备份的节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708231653652-1247302354.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空队
    if (queue-&amp;gt;front == queue-&amp;gt;rear) {
        return;
    }
    // 备份队首
    Node *t = queue-&amp;gt;front-&amp;gt;next;
    // 出队
    queue-&amp;gt;front-&amp;gt;next = t-&amp;gt;next;
    // 释放队首内存
    free(t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而对于没有头节点的队列来说，需要删除的则是这个&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708231952100-1958724026.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;类似的，先备份&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232111041-1113198840.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;出队&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232253140-580255912.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后释放内存，主要出队时和有头节点的区别&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232339013-343707855.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过这里需要注意一下，当只有一个节点，而又出队时&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232540472-2048663088.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232614740-1013374856.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232652423-1001154541.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232729168-1862090522.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当出队后，rear 仍然指向上一个 node 的地址，但是那个 node 已经被释放了，所以需要把它改为指向 NULL 才行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708232833493-196275668.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;换为代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空队
    if (queue-&amp;gt;front == queue-&amp;gt;rear) {
        return;
    }
    // 备份队首
    Node *t = queue-&amp;gt;front;
    // 出队
    queue-&amp;gt;front = t-&amp;gt;next;
    // 释放队首内存
    free(t);
    // 判断是否又变为空 queue
    if (queue-&amp;gt;front == NULL) {
        queue-&amp;gt;rear = NULL;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;实际操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无头节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

// 队伍每个节点
typedef struct {
    int data;
    struct Node *next;
} Node;

// queue
typedef struct {
    Node *front;
    Node *rear;
} Queue;

// init queue
Queue CreateQueue() {
    // 分配给 Queue 存两个指针的内存
    Queue *queue = (Queue *) malloc(sizeof(Queue));
    // 两指针指向 NULL
    queue-&amp;gt;rear = NULL;
    queue-&amp;gt;front = NULL;

    return *queue;
}

// 入队
void EnQueue(Queue *queue, int data) {
    // 建立新 node
    Node *new_node = (Node *) malloc(sizeof(Node));
    // 存值
    new_node-&amp;gt;data = data;
    // 新 node 对成为队尾，队尾指向 NULL
    new_node-&amp;gt;next = NULL;

    // 如果是没有头节点，且第一次入队
    if (queue-&amp;gt;rear == NULL &amp;amp;&amp;amp; queue-&amp;gt;front == NULL) {
        queue-&amp;gt;rear = new_node;
        queue-&amp;gt;front = new_node;
        return;
    }

    // 尾节点连接新 node
    queue-&amp;gt;rear-&amp;gt;next = (struct Node *) new_node;
    // 尾指针指向新 node
    queue-&amp;gt;rear = new_node;
}

// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空队
    if (queue-&amp;gt;front == queue-&amp;gt;rear) {
        return;
    }
    // 备份队首
    Node *t = queue-&amp;gt;front;
    // 出队
    queue-&amp;gt;front = t-&amp;gt;next;
    // 释放队首内存
    free(t);
    // 判断是否又变为空 queue
    if (queue-&amp;gt;front == NULL) {
        queue-&amp;gt;rear = NULL;
    }
}

void TraverseQueue(Queue queue) {
    while (queue.rear != queue.front) {
        printf(&amp;quot;%d\n&amp;quot;, queue.front-&amp;gt;data);
        queue.front = queue.front-&amp;gt;next;
    }
    printf(&amp;quot;%d\n&amp;quot;, queue.front-&amp;gt;data);
};


int main(void) {
    Queue queue = CreateQueue();
    EnQueue(&amp;amp;queue, 1);
    EnQueue(&amp;amp;queue, 2);
    EnQueue(&amp;amp;queue, 3);
    EnQueue(&amp;amp;queue, 4);
    EnQueue(&amp;amp;queue, 5);

    TraverseQueue(queue);

    printf(&amp;quot;###\n&amp;quot;);

    DeQueue(&amp;amp;queue);
    DeQueue(&amp;amp;queue);
    TraverseQueue(queue);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有头节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

// 队伍每个节点
typedef struct {
    int data;
    struct Node *next;
} Node;

typedef struct {
    Node *front;
    Node *rear;
} Queue;

// 初始化队伍
Queue CreateQueue() {
    // 分配给 Queue 存两个指针的内存
    Queue *queue = (Queue *) malloc(sizeof(Queue));
    // 分配首节点
    Node *new_node = (Node *) malloc(sizeof(Node));
    // 首节点下一个指向 NULL
    new_node-&amp;gt;next = NULL;
    // queue 两指针指向首节点
    queue-&amp;gt;front = new_node;
    queue-&amp;gt;rear = new_node;

    return *queue;
}

// 入队
void EnQueue(Queue *queue, int data) {
    // 建立新 node
    Node *new_node = (Node *) malloc(sizeof(Node));
    // 存值
    new_node-&amp;gt;data = data;
    // 新 node 对成为队尾，队尾指向 NULL
    new_node-&amp;gt;next = NULL;
    // 尾节点连接新 node
    queue-&amp;gt;rear-&amp;gt;next = (struct Node *) new_node;
    // 尾指针指向新 node
    queue-&amp;gt;rear = new_node;
}

// 出队
void DeQueue(Queue *queue) {
    // 判断是否为空队
    if (queue-&amp;gt;front == queue-&amp;gt;rear) {
        return;
    }
    // 备份队首
    Node *t = queue-&amp;gt;front-&amp;gt;next;
    // 出队
    queue-&amp;gt;front-&amp;gt;next = t-&amp;gt;next;
    // 释放队首内存
    free(t);
}

void TraverseQueue(Queue queue) {
    queue.front = queue.front-&amp;gt;next;
    while (queue.rear != queue.front) {
        printf(&amp;quot;%d\n&amp;quot;, queue.front-&amp;gt;data);
        queue.front = queue.front-&amp;gt;next;
    }
    printf(&amp;quot;%d\n&amp;quot;, queue.front-&amp;gt;data);
};


int main(void) {
    Queue queue = CreateQueue();
    EnQueue(&amp;amp;queue, 1);
    EnQueue(&amp;amp;queue, 2);
    EnQueue(&amp;amp;queue, 3);
    EnQueue(&amp;amp;queue, 4);
    EnQueue(&amp;amp;queue, 5);

    TraverseQueue(queue);

    printf(&amp;quot;###\n&amp;quot;);

    DeQueue(&amp;amp;queue);
    DeQueue(&amp;amp;queue);
    DeQueue(&amp;amp;queue);
    TraverseQueue(queue);


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;双端队列&#34;&gt;双端队列&lt;/h3&gt;

&lt;p&gt;双端队列即在队首，队尾都支持入队出队的队列，同样的可以顺序存储，或链式存储。不过顺序存储的话，如果是刚开始在 array[0] 处，无论是队首还是队尾都不能完全支持入队或出队，除非是在 array 中间某处开始。&lt;/p&gt;

&lt;p&gt;或者用 array 来实现环状的双端队列的话，也能实现，不过考虑的情况就有些多了，这里还是拿链式存储来做例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709153514474-759575746.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct {
    int data;
    struct Node *next;
    struct Node *pre;
} Node;

typedef struct {
    Node *front;
    Node *rear;
} Deque;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709154115134-659688054.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709154150118-462142249.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同样的，链式存储的双端队列也有头尾节点或没有头尾节点的情况。&lt;/p&gt;

&lt;p&gt;没有头，尾节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709154351278-1441424112.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Deque CreateDeque() {
    Deque *deque = (Deque *) malloc(sizeof(Deque));
    deque-&amp;gt;rear = NULL;
    deque-&amp;gt;front = NULL;

    return *deque;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有头，尾节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709155639748-74119729.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Deque CreateDeque() {
    Deque *deque = (Deque *) malloc(sizeof(Deque));

    Node *head_node = (Node *) malloc(sizeof(Node));
    Node *tail_node = (Node *) malloc(sizeof(Node));

    head_node-&amp;gt;pre = NULL;
    head_node-&amp;gt;next = tail_node;
    tail_node-&amp;gt;next = NULL;
    tail_node-&amp;gt;pre = head_node;

    deque-&amp;gt;front = head_node;
    deque-&amp;gt;rear = tail_node;

    return *deque;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;队列主要的操作就是入队和出队，而双端队列则有四种情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队首入队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有头节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709160609963-1025707089.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709160736075-255610205.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709160844888-270350279.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709165927445-494104192.png&#34; alt=&#34;&#34; /&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709165954773-225640807.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709170023940-543611572.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void InsertFront(Deque *deque, int data) {
    Node *new_node = (Node *) malloc(sizeof(Node));
    new_node-&amp;gt;data = data;
    new_node-&amp;gt;next = deque-&amp;gt;front-&amp;gt;next;
    Node *t = deque-&amp;gt;front-&amp;gt;next;
    t-&amp;gt;pre = new_node;
    deque-&amp;gt;front-&amp;gt;next = new_node;
    new_node-&amp;gt;pre = deque-&amp;gt;front;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有头节点&lt;/p&gt;

&lt;p&gt;第一次入队&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709170201001-477059955.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709171025236-242945492.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709171235628-1004055481.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709171352154-208500699.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709171441048-305193196.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200709171815387-775050871.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void InsertFront(Deque *deque, int data) {
    Node *new_node = (Node *) malloc(sizeof(Node));
    new_node-&amp;gt;data = data;

    // 第一次入队
    if (deque-&amp;gt;front == NULL &amp;amp;&amp;amp; deque-&amp;gt;rear == NULL) {
        new_node-&amp;gt;pre = NULL;
        new_node-&amp;gt;next = NULL;
        deque-&amp;gt;rear = new_node;
        deque-&amp;gt;front = new_node;
        return;
    }
    // 第二次入队
    if (deque-&amp;gt;front-&amp;gt;next == NULL &amp;amp;&amp;amp; deque-&amp;gt;rear-&amp;gt;pre == NULL) {
        deque-&amp;gt;front-&amp;gt;next = new_node;
        deque-&amp;gt;rear = new_node;
        new_node-&amp;gt;next = NULL;
        new_node-&amp;gt;pre = deque-&amp;gt;front;
        return;
    }
    new_node-&amp;gt;next = deque-&amp;gt;front-&amp;gt;next;
    Node *t = deque-&amp;gt;front-&amp;gt;next;
    t-&amp;gt;pre = new_node;
    deque-&amp;gt;front-&amp;gt;next = new_node;
    new_node-&amp;gt;pre = deque-&amp;gt;front;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;队首出队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队尾入队&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队尾出队&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;优先队列&#34;&gt;优先队列&lt;/h3&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000022089417&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;数据结构之 循环队列&lt;/a&gt;
&lt;a href=&#34;http://data.biancheng.net/view/173.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;顺序队列&lt;/a&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000022294283&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;C 语言数据结构之链队列&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://data.biancheng.net/view/174.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;链式队列及基本操作（C 语言）完全攻略&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;队列&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;a&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;大话数据结构第4章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5e9490965188257396517a35&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;数据结构与算法 07—— 链队列&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>i3 用户指南（翻译）</title>
      <link>https://edte.github.io/2020/2020-06-21-i3-%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-21-i3-%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这篇文章是 &lt;a href=&#34;https://i3wm.org/docs/userguide.html#hidpi&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;i3 User’s Guide&lt;/a&gt; 的中文翻译，主要是因为国内 i3 比较小众，相关的配置博客都只是讲了他做了些什么，而没有讲为什么要这么做，以及其他 i3 能做些什么。因此我想借此机会学习一下配置 i3，同时学一下英语。&lt;/p&gt;

&lt;p&gt;文档只要能够读懂，并且据此能成功配置即可，对原文是怎样表达的并不重视，同时许多术语对应的翻译也有差异，而母语使用者面对未知的术语可能还无法理解其意。&lt;/p&gt;

&lt;p&gt;基于上面的观点，这篇文章并不逐字翻译，而是意译, 同时读者读这篇文章都是为了直接配置 i3， 因此我会在模糊的地方加上一些注解。&lt;/p&gt;

&lt;p&gt;本人能力难免有不足之处，欢迎各位指出不当之处，我会在确认后修改。&lt;/p&gt;

&lt;h2 id=&#34;绑定的默认键&#34;&gt;绑定的默认键&lt;/h2&gt;

&lt;p&gt;对于那些认为文章太长，不想往下看的读者，这里有默认键的概述（点击查看原图）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用 $mod (Alt) 键:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i3wm.org/docs/keyboard-layer1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用 Shift+$mod 键:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i3wm.org/docs/keyboard-layer2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;红色的键是你需要按的修饰键（默认情况），蓝色的键则是你没有按键时，手指放的位置。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;译者注：红色的键就是设置组合键时，需要先按的那个键，一般左手按这个键，如 Ctrl，Fn 等，然后设置其他的键来形成组合键。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;请注意，当你启动 i3 时，如果没有配置文件，i3-config-wizard 这个工具会自动生成一个配置文件，不管你的键盘布局是哪种，这个配置文件都会在关键的配置上，与上面的图片相同。如果你更喜欢使用配置文件，并且按键和上面的一样，只需关闭 i3-config-wizard，然后基于 &lt;code&gt;/etc/i3/config&lt;/code&gt; 修改配置文件。&lt;/p&gt;

&lt;h2 id=&#34;使用-i3&#34;&gt;使用 i3&lt;/h2&gt;

&lt;p&gt;在这篇文章中，&lt;code&gt;$mod&lt;/code&gt;  指设置好的修饰键（上面红色那个键）。默认情况 &lt;code&gt;$mod&lt;/code&gt; 是指 &lt;code&gt;Alt&lt;/code&gt;(Mod1) 键，为了避免快捷键冲突，使用 &lt;code&gt;Windows&lt;/code&gt;(Mod4) 键是个好主意。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;上面的说明可能有点不容易理解&lt;/p&gt;

&lt;p&gt;，$mod 是你可以设置的键，Mod1 表示 Alt 键，Mod4 表示 Windows 键，如可以使用 set $mod Mod1 把 $mod 设置为 Alt 键&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;打开和移动终端&#34;&gt;打开和移动终端&lt;/h3&gt;

&lt;p&gt;有一个操作是很常用的，即打开终端。默认情况下，这个操作的快捷键是 &lt;code&gt;$mod+Enter&lt;/code&gt;, 即 &lt;code&gt;Alt+Enter&lt;/code&gt;(Mod1+Enter), 按下 &lt;code&gt;$mod+Enter&lt;/code&gt; 后，会打开一个终端，这个终端会占满屏幕。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i3wm.org/docs/single_terminal.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你继续打开另一个终端，i3 会把屏幕分为两半，然后在现有的终端旁再加一个。根据你的屏幕不同，i3 会把新终端放在现有的终端右边（宽屏），或者把新终端放在现有的终端下面（旋转屏）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i3wm.org/docs/two_terminals.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要在两个终端间移动焦点，你可以使用在 &lt;code&gt;vi&lt;/code&gt; 中使用的方向键。但是，在 i3 中，这些键已经被使用了。（在 &lt;code&gt;vi&lt;/code&gt; 里，向左移动一次，在在大多数键盘布局都是兼容的。）因此，&lt;code&gt;$mod+j&lt;/code&gt; 向左，&lt;code&gt;$mod+k&lt;/code&gt; 向下，&lt;code&gt;$mod+l&lt;/code&gt; 向上，&lt;code&gt;$mod+;&lt;/code&gt; 向右。所以，要在这些窗口间移动，使用 &lt;code&gt;$mod+k&lt;/code&gt; 或 &lt;code&gt;$mod+l&lt;/code&gt;, 当然，也可以使用箭头方向键。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在 vim 中，h -&amp;gt; left, j -&amp;gt; down, k -&amp;gt; up, l -&amp;gt; right, 如果使用 vim 的话，可以加上 $mod 来改变焦点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在，你的工作区（workspace) 是分开的（有两个终端）在特殊方向（默认水平）。像工作区一样，每个窗口都可以再次水平或垂直分割。术语窗口（window) 是指实际上包含 x11 window (像终端或浏览器) 的容器（container)。对于容器来说，拆分容器则是指一个或多个窗口。&lt;/p&gt;

&lt;p&gt;待完成： 树（tree）的图片&lt;/p&gt;

&lt;p&gt;要垂直拆分窗口，请在建立窗口前按 &lt;code&gt;$mod+v&lt;/code&gt;, 要水平拆分窗口，按 &lt;code&gt;$mod+h&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;改变容器的布局&#34;&gt;改变容器的布局&lt;/h3&gt;

&lt;p&gt;一个分割的容器，可以拥有以下布局之一：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;splith/splitv&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这个模式下，窗口可以调整大小，这样可以保证每个容器下的窗口有相同的空间。splith 将窗口水平分布（新窗口在右边），splitv 将窗口垂直分布（新窗口在下面）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stacking&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;仅显示聚焦的窗口，窗口列表会显示在容器顶部。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tabbed&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类似 stacking, 但是窗口列表只有一行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i3wm.org/docs/modes.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换窗口的全屏模式&#34;&gt;切换窗口的全屏模式&lt;/h3&gt;

&lt;p&gt;要把窗口全屏显示，或者退出全屏，按 &lt;code&gt;$mod+f&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;i3 同样有一个全局全屏模式，这个模式下，所有客户端可用的输出都会被覆盖（命令是 fullscreen toggle global）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;按 &lt;code&gt;$mod+f&lt;/code&gt; 就是某个窗口进入或退出全屏，全局全屏模式就是所有屏幕都是全屏，自然不是全屏的窗口会被覆盖&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;打开其他应用&#34;&gt;打开其他应用&lt;/h3&gt;

&lt;p&gt;除了从终端打开应用，你同样可以使用便利的 &lt;code&gt;dmenu&lt;/code&gt;, 默认按 &lt;code&gt;$mod+d&lt;/code&gt; 来启动 &lt;code&gt;dmenu&lt;/code&gt;。仅仅需要输入你想要打开的应用的名字（或者一部分）。相应的程序，需要在你设置的 &lt;code&gt;$PATH&lt;/code&gt; 下才能被成功打开。&lt;/p&gt;

&lt;p&gt;此外，如果你有经常使用的应用，你可以直接为这个应用创建快捷键，看下面配置 i3 这部分查看更详细的细节。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;推荐使用 rofi 代替 demu, demu 太丑了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用工作区&#34;&gt;使用工作区&lt;/h3&gt;

&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;

&lt;h2 id=&#34;配置-i3&#34;&gt;配置 i3&lt;/h2&gt;

&lt;h2 id=&#34;配置-i3bar&#34;&gt;配置 i3bar&lt;/h2&gt;

&lt;h2 id=&#34;命令清单&#34;&gt;命令清单&lt;/h2&gt;

&lt;h2 id=&#34;多显示器&#34;&gt;多显示器&lt;/h2&gt;

&lt;h2 id=&#34;i3-和其他软件&#34;&gt;i3 和其他软件&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/I3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;i3/en&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/I3_(简体中文)#设置&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;i3/cn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://i3wm.org/docs/userguide.html#hidpi&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;i3 User’s Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://translate.google.cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;伟大的 google translate&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>图解链表</title>
      <link>https://edte.github.io/2020/2020-06-19-%E5%9B%BE%E8%A7%A3%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-19-%E5%9B%BE%E8%A7%A3%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这篇文章是我学习链表的笔记总结，没有主要参考的书籍，尝试过阅读《大话数据结构》，但是这本书读着不太舒服，主要参考各种博客，以及刷了一些 leetcode 上的链表的题来巩固。&lt;/p&gt;

&lt;p&gt;这篇文章同样的，在使用一些术语时，我会尽量使用英文。另外有大量的原创图，以及 c 语言的具体实现。&lt;/p&gt;

&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;

&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;链表(linked list) 是一种线性表（linear list），元素（element）间一对一，逻辑上相连，但是在内存上分配不连续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;链表每个元素被称为节点（node), 由数据域（data filed）和 指针域（pointer filed) 组成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184201583-1984204170.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;linked list 的每个 node 在内存上并不相连，如&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184247356-521746961.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因此，node 间想要相连，就需要知道下一个 node 的 address，这就要借助 pointer。故每个 node 的 data filed 存这个 node 的 data， 而 pointer filed 则存下一个 node 的 address。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184327666-1502414754.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们知道链表的节点是有限的，所以最后一个 node 就没有下一个 node，故最后一个 node 的 pointer filed  存的 addres 就为 NULL.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184353106-2007072250.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;性质&#34;&gt;性质&lt;/h3&gt;

&lt;p&gt;因为每个 node 都存下一个node 的 address，所以要访问一个 node 的话，就需要知道上一个 node 才行，故 linked list 查找（search） 元素，更新（update）元素，插入元素（insert），删除（delete）元素都需要先找到这个 node，所以就需要遍历链表。&lt;/p&gt;

&lt;p&gt;search 和 update 需要遍历链表，故需要一个一个的找，时间复杂度是 O(n).&lt;/p&gt;

&lt;p&gt;insert 和 delete 不算遍历的过程，只是执行 insert  和 delete 的话，只需更改 address 即可，故时间复杂度是 O(1).&lt;/p&gt;

&lt;p&gt;这里看字不容易理解，可以继续往下看具体的代码实现，那里有详细的图解说明。&lt;/p&gt;

&lt;h3 id=&#34;头指针-头节点-首元节点&#34;&gt;头指针/头节点/首元节点&lt;/h3&gt;

&lt;p&gt;这三个是链表中容易搞混的概念，我们这里用来解释一下。&lt;/p&gt;

&lt;p&gt;我们现在知道链表是由 node 组成的，现在我们先来弄几个 node 组成的链表&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184454140-1799275026.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们要操作这个链表，肯定需要知道首地址(head address)，如果我们要在函数中操作这个链表，也需要把首地址传进去，那干脆直接用个头指针(head pointer) 指向第一个节点，这个指针就是 head pointer, 我们需要操作链表，所以这个是必须要有的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184519587-201998762.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在如果我们要在链表中间插入 node, 前面有 node，操作方式都是一样的，但是如果我们要在第一个节点前加一个 node 的话，前面没有 node， 那么在 intert 函数中肯定要分情况。&lt;/p&gt;

&lt;p&gt;同样的，由有链表在内存中是不连续分配的，那么我们怎么知道一共有多少个 node 呢，所以为了解决这些问题，有时候我们会在第一个节点前，也就是存真正的数据前的那个节点前再加一个节点，这个节点的 data filed 用来存链表长度等特殊的信息。同时操作插入第一个节点也比较方便，这个节点就叫头节点 (head node)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184600126-969117482.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经知道头节点和头指针是怎么回事了，首元节点就比较容易理解了，也就是存正式数据的第一个节点，如上面的 first node, 这是为了区分头节点取的名字&lt;/p&gt;

&lt;p&gt;因为有 head node 和没有 head node 这两种情况，所以在一些操作上也是有差距的，具体要看实际情况。&lt;/p&gt;

&lt;p&gt;如没有 head node 的空表, 直接头指针连接 NULL&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184637184-712092166.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而有 head node 的空表，则是 head node 连接 NULL&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184708386-1515518482.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627215708992-1005524645.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;链表在逻辑上都是一对一的关系，一般我们说的都是动态链表，即在物理上元素间靠指针相连，个数不定。&lt;/p&gt;

&lt;p&gt;而在声明链表时就划分好一定的内存（相连的），靠 array 的形式组成的链表，被称为静态链表。&lt;/p&gt;

&lt;p&gt;一般不主动说明是静态链表时，都说的是动态链表。&lt;/p&gt;

&lt;p&gt;注意静态链表和顺序表的区别。&lt;/p&gt;

&lt;p&gt;单链表(single linked list node)：每个节点只存下一个节点的地址和数据&lt;/p&gt;

&lt;p&gt;单链表的节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184736227-1282876189.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;普通的单链表&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184801675-1006347099.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;单链表中还有一种特殊的情况，尾节点（tail node）不指向 NULL，而指向 head pointer，那这个链表就成为了一个环，这个链表叫做单向循环链表（circular linked list）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184825462-847162229.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双链表（double linked list）对应于单链表，双链表每个 node 存上一个和下一个 node 的地址，以及 data。&lt;/p&gt;

&lt;p&gt;节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184859846-2055122044.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双链表&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200624154251625-1124196113.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们在上面说了单链表中有单向循环链表这种特殊情况，容易理解，双链表中也有这种情况。双链表的尾节点（tail node） 指向 head node，那这个链表即双向循环链表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200624155116089-2003051847.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;单链表&#34;&gt;单链表&lt;/h2&gt;

&lt;h3 id=&#34;create&#34;&gt;create&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;单链表是链表中的一种，每个 node 存下一个 node 的地址以及数据，单链表是单向的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;single linked list 是由 node 组成的，要实现的话首先就要实现 node&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708184954627-1961501831.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// single linked list node
typedef struct {
    int data;  // data filed
    struct Node *next;  // pointer filed
} Node;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码声明了 single linked list 的 node ，然后声明了存数据的 data，以及存下一个 node address 的 next.&lt;/p&gt;

&lt;p&gt;我们在前面说了，单链表可以有头节点或没有，很多时候我们会建立头节点，所以这里还是以有头节点为例子。&lt;/p&gt;

&lt;p&gt;我们继续，来创个函数来声明 single linked list&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185025427-539074144.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CreateList 建立一个有头节点的单链表
Node *Createlist() {
    // 头节点
    Node *new_node = malloc(sizeof(int));
    if (new_node == NULL) {
        printf(&amp;quot;crete linked list failed!&amp;quot;);
        exit(-1);
    }
    // 空表，指向 NULL
    new_node-&amp;gt;next = NULL;
//    new_node-&amp;gt;data=  0;
    return new_node;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数建立了一个有头节点的单链表，然后返回头节点，要使用的话，需要赋值给头指针，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(void) {
	Node *head = Createlist();
	
	return 0;
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在这个函数中，使用 malloc 函数分配了内存给头节点，然后判断是否分配成功，再指向 NULL，然后头节点的 data filed 自己看存什么数据，这里我们没有存有意义的数据。然后返回这个头节点。&lt;/p&gt;

&lt;p&gt;这个函数没有传入参数，而是把头节点返回，我们也可以把头节点直接传进去，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 传入 Node 指针的指针，因为要在函数改变 Node 指针的值
void CreateList(Node **head) {
    // 先给头节点动态分配内存，然后把头指针指向这块内存，即指向头节点
    *head = (Node *) malloc(sizeof(int));
    if (*head == NULL) {
		printf(&amp;quot;create single linked list failed!&amp;quot;);
	}
    (*head)-&amp;gt;next = NULL;
//    (*head)-&amp;gt;data = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数同样的创建了一个有头节点的单链表，不过是把头指针当做参数传进去的。需要注意的是头指针 (head) 本身是指向节点的指针（Node *)，而要在函数中改变变量的值，需要传入其地址，故这里是传入头指针的地址，则传入就是指针的指针。然后分配内存，头指针指向头节点，设置 NULL，设置 data，这和刚才返回头节点的函数是相同的。&lt;/p&gt;

&lt;p&gt;要使用的话，需要传头指针&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(void) {
	Node *head = NULL;
	CreateList(&amp;amp;head);
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;insert&#34;&gt;insert&lt;/h3&gt;

&lt;p&gt;链表除了操作表本身，就是操作节点了。对链表节点的插入是比较常用的，这里有几种情况。&lt;/p&gt;

&lt;p&gt;首先我们来谈谈直接在末尾插入节点，要插入节点，首先要找到目标节点的位置。链表不支持随机访问（random access), 因为每个 node 的地址是不能直接拿到的，所以只能遍历去找目标节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185100146-402837814.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在单链表最后，插入一个元素， elem 是要插入的值
void InsertEndingElem(Node *head, int elem) {
    Node *now_node = head;  // 当前的 node，用于遍历 list
    Node *new_node = malloc(sizeof(int));  // 新建的 node ，即要插入的新 node

    // 判断是否新建 node 成功
    if (new_node == NULL) {
        printf(&amp;quot;insert ending element failed!&amp;quot;);
        exit(-1);
    }

    // 新建的 node 在 list 末尾，故需要指向 NULL， 同时设置 data
    new_node-&amp;gt;data = elem;
    new_node-&amp;gt;next = NULL;

    // 遍历 node，把当前 node 变为最后一个 node
    while (now_node-&amp;gt;next != NULL) {
        now_node = now_node-&amp;gt;next;
    }
    // 最后的 node 连接新 node
    now_node-&amp;gt;next = new_node;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数传入头指针和一个值，然后在末尾插入了一个新节点。&lt;/p&gt;

&lt;p&gt;我们先建立了用于遍历的当前节点 now_head, 初始在头节点（头指针）。然后建立了新节点 now_node, 判断是否建立成功，然后把值存在新节点，又这个节点插入后就变成了尾节点，所以要指向 NULL。然后我们通过判断当前节点的下一个是否为 NULL 来判断是否到了尾节点，当前节点一直移动到尾节点。然后当前节点（指向尾节点）连接新节点，这样就插入成功了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185124031-1810147579.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们这只是插入了一个节点，也可以封装一下，插入多个节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在单链表后插入多个元素， num 是数组首地址， n 是数组个数
void InsertEndingElmes(Node *head, int *nums, int n) {
    int i;

    for (i = 0; i &amp;lt; n; i++) {
        InsertEndingElem(head, nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数传入头指针，插入的数组首地址，数组个数，然后把数组中的元素以此插入到链表中。这里比较容易理解，遍历数组，依次调用插入函数即可。不过这里有个问题，因为每次调用插入函数时，都传入了 head 头指针，而每次调用后都要重新从 head 遍历到末尾，这就重复做了一些操作，可以思考一下怎么改进。&lt;/p&gt;

&lt;p&gt;我们刚刚实现了在尾节点（tail node) 后插入 node，现在我们来看一下其他地方又怎么实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185150386-1629517399.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设我们要在画圈的那个 node 后 insert 一个新的 node。同样的，我们需要 head pointer 记录开始的 node，需要一个当前节点 now_node 遍历到目标节点，然后插入节点，现在我们假设已经遍历找到了目标节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185217003-1765909141.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看图我们知道，要插入的话，只需把 now_node 和 new_node 连接起来，以及 new_node 和目标节点后面那个节点连接起来，也就是连两条线，那么先连哪条有区别吗？我们来看图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185241687-1392257849.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们先连 now_node 和 new_node 这条线，我们知道 now_node 现在即目标 node (圈起来的 node)，于是目标 node 连接原先后面的那些 node 断了，因为连接到 new node 去了。现在我们继续，我们现在需要把 new node 连接到圈后面的那个 node，可是刚刚已经断开了，如果我们没有记录它的地址的话，我们就找不到这个 node 了。所以如果先连这条线的话，需要先保存目标 node 后面的 node address&lt;/p&gt;

&lt;p&gt;我们来先连后面一条线看看&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185311346-287160537.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现每个 node 都在，并没有丢失&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185341927-1662003473.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们继续连第二条线，发现成功连上了，这说明我们成功插入了 node。&lt;/p&gt;

&lt;p&gt;从上面的分析知道，虽然先连哪条线都能成功，但是先断后连的话，需要占用内存去存 node 的地址，而先连后断则没有这一步，故我们一般都是先连后断的。&lt;/p&gt;

&lt;p&gt;通过上面的分析，我们发现，单链表要插入节点的话，只需更改一下 address 就可以了，其时间复杂度是 O(1)。&lt;/p&gt;

&lt;p&gt;我们刚刚分析了原理，现在来具体用代码实现一下，要插入元素的话，首先需要找到插入点，而根据插入点的类型，又多种情况，如在第 n 后插入，在第一个 val 为 m 的 node 后插入，还有延伸插入 n 个元素等。不过这是查询节点的内容，以及扩展的部分，只要原理清楚了，其他再进行拓展是比较容易的。我们这里就假设插入的目标节点是第一个 data 为 m 的 node&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 在第一个 data 为 val 的 node 后插入一个 node，其值为 d
void InsertElemByValue(Node *head, int val, int d) {
    Node *now_node = head;  //遍历用的 node

	// 找到插入点
    while (now_node-&amp;gt;data != val) {
        now_node = now_node-&amp;gt;next;
    }
    // 插入的 node
    Node *New_node = (Node *) malloc(sizeof(int));
    New_node-&amp;gt;data = d;
    // 插入，先连后断
    New_node-&amp;gt;next = now_node-&amp;gt;next;
    now_node-&amp;gt;next = New_node;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数在中间插入 node，首先遍历找到 data 为 val 的 node，然后建立好新 node，再用我们刚刚分析的，先连接，后断开的连线方式插入 node。&lt;/p&gt;

&lt;p&gt;我们分析了插入中间，以及末尾的节点，现在我们再来看下在开始插入节点又是怎样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202007/1823594-20200708185434567-255220530.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现如果有头节点（head node) 的话，同样的头指针记录头节点，当前节点从头节点遍历。我们可以和在中间插入对比一下，细心一点我们会发现它们的过程是一样的，事实上我们也可以把这个当作在头节点后插入节点，这也是在中间插入的一种。所以有头节点的话，实现比较容易理解。&lt;/p&gt;

&lt;p&gt;比如我们刚刚 InsertElemByValue() 函数, 如果 first node 的 val 值符合的话，那么是直接插入在 head node 后的，也就是插入第一个节点。&lt;/p&gt;

&lt;p&gt;但是我们知道，还有没有头节点这种情况，那么这种情况又是怎么样的呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200624164551294-98411547.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看图我们可以发现，由于没了 head node, 所以我们需要单独的设置，按照上面说的连续方式，我们需要先把 new node 连接到原先的 first node 上，然后把 head pointer 重新指向 new node。&lt;/p&gt;

&lt;p&gt;我们来看一下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 插入 fisrt node
void InsertNodeAfterHead(Node *head, int m) {
	// 建立 new node
    Node *new_node = (Node *)malloc(sizeof(int));
    new_node-&amp;gt;data = m;

	//  插入
    new_node-&amp;gt;next = head;
    head = new_node;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数直接在 head pointer 后，first node 前插入一个 node。主要是插入的过程需要多加思考，先 new node 连线到要插入的 node 后的那个 node,  这里要插入的 node 不存在，所以是连接到 first node, 然后 head pointer 重新指向 new node(现在变成了 first node).&lt;/p&gt;

&lt;p&gt;经过上面分析可以看出，如果有头节点的话，对头节点的操作和中间节点的操作是一样的，所以这也是我们一般要使用头节点的原因之一。&lt;/p&gt;

&lt;h3 id=&#34;delete&#34;&gt;delete&lt;/h3&gt;

&lt;p&gt;linked list 的重难点就是 insert 和 delete element 的过程，我们现在再来看下 delete element 的过程是怎么样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627185750679-1255766250.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们要删除圈起来的这个节点，怎么做呢？&lt;/p&gt;

&lt;p&gt;我们知道链表中是使用指针将它们连接起来的，所以只需要不连接这个 node 就可以了，那我们可以直接找到前面那个节点，然后跳过这个节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627190128952-762830534.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们假设要删除第 n 个节点，所以需要先找到 n-1 个节点，然后跳过第 n 个节点，我们来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 删除第 m 个元素
void DeleteElem(Node *head, int m) {
	int i;
	Node *now_node = head;
	// 找到第 m - 1 个元素
	for (i = 0; i &amp;lt; m - 1; i++) {
		now_node = now_node-&amp;gt;next;
	}
	// 删除元素
	now_node-&amp;gt;next = (now_node-&amp;gt;next)-&amp;gt;next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数删除了第 m 个元素，先找到第 m - 1 个元素，然后删除这个元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627193935707-265488771.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们可以看到，删除的这个元素没有释放，那它占用的内存就被浪费了，这就发生了内存泄漏。我们可以先释放内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 删除第 m 个元素
void DeleteElem(Node *head, int m) {
	int i;
	Node *now_node = head;
	// 找到第 m - 1 个元素
	for (i = 0; i &amp;lt; m - 1; i++) {
		now_node = now_node-&amp;gt;next;
	}
	// 先备份地址
	Node *temp = now_node-&amp;gt;next;

	// 删除元素
	now_node-&amp;gt;next = (now_node-&amp;gt;next)-&amp;gt;next;

	// 释放内存
	free(temp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们刚刚是删除了第 n 个元素，这种情况我们可以直接找到第 n 个元素，但是如果我们不知道要删除的元素位置呢？&lt;/p&gt;

&lt;p&gt;如给一个值，然后删除值匹配的元素。这样的话我们就遍历匹配，但是只有当遍历到目标节点，才知道要删除的节点是那个，这样的话，除非我们保存了前面节点的地址，不然的话就不能像刚刚那种方法删除。&lt;/p&gt;

&lt;p&gt;或者直接给一个 node，然后要你删除掉这个 node，这时候该怎么办？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627194938075-895123889.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;单链表只能往下遍历，不能往前遍历，所以这样是不行的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627195126953-545428397.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是删除节点只能这样，我们现在只能这样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627195313147-135587190.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们要删除的节点是后面这个就好了，等一下，既然如此，那我们只需要把要删除的节点变成后面这个不久好了？&lt;/p&gt;

&lt;p&gt;假设原来的数据是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627195516443-360390475.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;删除后是这样的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627195601208-946497892.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们可以把圈起来那个节点的值，变成下一个节点的值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627195708833-1882831197.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那我们要删除的节点就可以变成下一个节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627195743105-631587271.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有人可能会说，可是它们的地址变了呀，对，是变了，但是我们只关心它们的值，地址是无需关心的。&lt;/p&gt;

&lt;p&gt;我们来实现一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void DeleteThisNode(Node *node) {
	// 复制值
	node-&amp;gt;data = (node-&amp;gt;next)-&amp;gt;data;
	// 删除 node
	node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数删除了给定的这个 node，首先把删除的这个 node 的值变成下一个 node 的值，然后删除下一个 node。即把要删除的 node 变成下一个 node。&lt;/p&gt;

&lt;p&gt;我们刚刚都是只删除了相邻的 node，我们也可以删除相邻的几个 node&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200627200418596-605890406.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看图的话，知道原理其实都是差不多的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node-&amp;gt;next = ((node-&amp;gt;next)-&amp;gt;next)-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然还要释放一下内存，避免浪费。&lt;/p&gt;

&lt;p&gt;上面都只删除了一个 node，当然我们也可以同时删除多个 node，如传入一个 array，然后删除里面的元素，或者删除多个值匹配的 node，这些都是在上面的基础上组合而成的，总之原理都差不多，这里就不展开了。&lt;/p&gt;

&lt;h3 id=&#34;search&#34;&gt;search&lt;/h3&gt;

&lt;h3 id=&#34;update&#34;&gt;update&lt;/h3&gt;

&lt;h2 id=&#34;双链表&#34;&gt;双链表&lt;/h2&gt;

&lt;h3 id=&#34;create-1&#34;&gt;create&lt;/h3&gt;

&lt;h3 id=&#34;insert-1&#34;&gt;insert&lt;/h3&gt;

&lt;h3 id=&#34;delete-1&#34;&gt;delete&lt;/h3&gt;

&lt;h3 id=&#34;search-1&#34;&gt;search&lt;/h3&gt;

&lt;h3 id=&#34;update-1&#34;&gt;update&lt;/h3&gt;

&lt;h2 id=&#34;循环链表&#34;&gt;循环链表&lt;/h2&gt;

&lt;h3 id=&#34;单向循环链表&#34;&gt;单向循环链表&lt;/h3&gt;

&lt;h3 id=&#34;双向循环链表&#34;&gt;双向循环链表&lt;/h3&gt;

&lt;h2 id=&#34;静-动态链表&#34;&gt;静/动态链表&lt;/h2&gt;

&lt;h3 id=&#34;静态链表&#34;&gt;静态链表&lt;/h3&gt;

&lt;p&gt;静态单链表&lt;/p&gt;

&lt;p&gt;静态单循环链表&lt;/p&gt;

&lt;p&gt;静态双链表&lt;/p&gt;

&lt;p&gt;静态双循环链表&lt;/p&gt;

&lt;h3 id=&#34;动态链表&#34;&gt;动态链表&lt;/h3&gt;

&lt;p&gt;动态单链表&lt;/p&gt;

&lt;p&gt;动态单循环链表&lt;/p&gt;

&lt;p&gt;动态双链表&lt;/p&gt;

&lt;p&gt;动态双循环链表&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/链表&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;链表&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>markdown 学习笔记</title>
      <link>https://edte.github.io/2020/2020-06-12-markdown-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-12-markdown-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 是一种&lt;a href=&#34;https://zh.wikipedia.org/wiki/轻量级标记语言&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;轻量级标记语言&lt;/a&gt;，创始人为&lt;a href=&#34;https://zh.wikipedia.org/wiki/約翰·格魯伯&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;约翰・格鲁伯&lt;/a&gt;（英语： John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/XHTML&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;XHTML&lt;/a&gt;（或者 &lt;a href=&#34;https://zh.wikipedia.org/wiki/HTML&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;HTML&lt;/a&gt;）文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;标题&#34;&gt;标题&lt;/h2&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用 &lt;code&gt;#&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;#&lt;/code&gt; 符号可以设置标题，markdown 一共支持六种标题，对应着 html 中的 h1~h6。&lt;/p&gt;

&lt;p&gt;建议在 &lt;code&gt;#&lt;/code&gt; 后加上一个空格，这是标准的格式，同时在实际使用中，一般都使用 h2~h4, h1 太大，而 h5 后面的则设置标题太多，一般建议使用无序列表代替。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612222139424-1387886975.png&#34; alt=&#34;标题&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用-和&#34;&gt;使用 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;markdown 还支持 多个 &lt;code&gt;=&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 设置一级标题和二级标题，不够有些解析器并不支持这个语法，所以一般都是使用的 &lt;code&gt;#&lt;/code&gt; 语法。一般要使用这个语法的话，虽然对 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 的长度没有特殊要求，但是还是建议和标题设置得一样长，这样舒服些。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一级标题
======

二级标题
------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612222849193-2001459215.png&#34; alt=&#34;标题&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;段落&#34;&gt;段落&lt;/h2&gt;

&lt;p&gt;markdown 的段落没有什么特殊的语法，直接写就是，要分段时直接用空白行分割开即可。常见的就是直接按两到三次回车，即在段落间有两到三个空白行分割。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个段落。

这又是一个段落。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612224550457-2104814836.png&#34; alt=&#34;段落&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;字体&#34;&gt;字体&lt;/h2&gt;

&lt;p&gt;markdown 使用 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 标记字体，两者效果相同。&lt;/p&gt;

&lt;h3 id=&#34;斜体&#34;&gt;斜体&lt;/h3&gt;

&lt;p&gt;使用两个 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 把字体围起来，表示斜体, 注意不要在中间加空格，下同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*我是斜体*

_我是斜体_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612230146952-537470422.png&#34; alt=&#34;斜体&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;粗体&#34;&gt;粗体&lt;/h3&gt;

&lt;p&gt;使用四个 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 把字体围起来，表示粗体。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;**我是粗体**

__我是粗体__
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612230317896-1846971416.png&#34; alt=&#34;粗体&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;粗斜体&#34;&gt;粗斜体&lt;/h3&gt;

&lt;p&gt;使用六个 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 把字体围起来，表示粗斜体。主要是六个，不能多了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;***我是粗斜体***

___我是粗斜体___
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612230549025-2013575072.png&#34; alt=&#34;粗斜体&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;p&gt;如果要在 markdown 中引入别人的文本，可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 语法，在 &lt;code&gt;&amp;gt;&lt;/code&gt; 后加一个空格，再加要引入的文本，如经常引用的 wiki 的介绍。&lt;/p&gt;

&lt;h3 id=&#34;普通&#34;&gt;普通&lt;/h3&gt;

&lt;p&gt;如果只引入一段文本，可以直接加一个 &lt;code&gt;&amp;gt;&lt;/code&gt; ，然后后面直接加文本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 电子邮件（英语：electronic mail），简称电邮（email、e-mail），是指一种由一寄件人将数位信息传送给一个人或多个人的信息交换方式，一般会通过网际网路或其他电脑网路进行书写、发送和接收信件，目的是达成发信人和收信人之间的信息交互。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612231950270-1802538318.png&#34; alt=&#34;引用&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况要结束引用的话，需要空一行。&lt;/p&gt;

&lt;p&gt;如果要一句一句的引入，也可以每行都加一个 &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 电子邮件（英语：electronic mail），简称电邮（email、e-mail）
&amp;gt; 是指一种由一寄件人将数位信息传送给一个人或多个人的信息交换方式
&amp;gt; 一般会通过网际网路或其他电脑网路进行书写、发送和接收信件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612232346199-331560309.png&#34; alt=&#34;引用&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而这种情况要结束引用，也需要空一行，如果上一行行首有 &lt;code&gt;&amp;gt;&lt;/code&gt; 的话，下一行也默认跟着引用的。&lt;/p&gt;

&lt;h3 id=&#34;嵌套&#34;&gt;嵌套&lt;/h3&gt;

&lt;p&gt;要在引用中继续引用其他人的语句，也可以嵌套使用，语法都查不多&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 最外层
&amp;gt; &amp;gt; 第一层嵌套
&amp;gt; &amp;gt; &amp;gt; 第二层嵌套
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612232639526-899320660.png&#34; alt=&#34;引用&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用其他语法&#34;&gt;使用其他语法&lt;/h3&gt;

&lt;p&gt;在引用块中也支持其他语法，如标题，字体，列表，表格等等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; ## This is a header.
&amp;gt;
&amp;gt; 1.   This is the first list item.
&amp;gt; 2.   This is the second list item.
&amp;gt;
&amp;gt; Here&#39;s some example code:
&amp;gt;
&amp;gt;     return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200612233219578-77306837.png&#34; alt=&#34;sdf&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;

&lt;p&gt;markdown 支持无序列表和有序列表，如果标题级数太多，还可以使用列表来当标题使用。&lt;/p&gt;

&lt;h3 id=&#34;无序列表&#34;&gt;无序列表&lt;/h3&gt;

&lt;p&gt;markdown 支持 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;+&lt;/code&gt; 来标记无序列表，在文本前加一个空格是标准格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 第一项
* 第二项
* 第三项

+ 第一项
+ 第二项
+ 第三项


- 第一项
- 第二项
- 第三项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;有序列表&#34;&gt;有序列表&lt;/h3&gt;

&lt;p&gt;markdown 使用 数字加 &lt;code&gt;.&lt;/code&gt; 标记有序列表。注意同样要加一个空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 我是第一
2. 我是第二
3. 我是第三
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613133224992-1490144483.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有序列表并不是必须从 1. 开始，只要符合这个语法都能够渲染, 不过实际上这样反而达不到有序的目的了，还是建议从 1 开始。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4. 我是第四
5. 我是第五
6. 我是第六
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613133414911-457545360.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;任务列表&#34;&gt;任务列表&lt;/h3&gt;

&lt;p&gt;任务列表不是官方语法，但是在许多地方都支持，如常用的 github&lt;/p&gt;

&lt;p&gt;语法 &lt;code&gt;- [] list_name&lt;/code&gt; ，&lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;[]&lt;/code&gt; 后都要加空格, &lt;code&gt;[]&lt;/code&gt; 里加一个空格表示没有完成，在里打个 &lt;code&gt;x&lt;/code&gt;, 即 &lt;code&gt;[x]&lt;/code&gt; 表示已经完成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- [x] 洗碗
- [ ] 清洗油烟机
- [ ] 拖地
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613170259049-529186485.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;列表嵌套&#34;&gt;列表嵌套&lt;/h3&gt;

&lt;p&gt;有是否我们需要在列表中嵌套使用，那么直接使用列表语法即可，只是需要在嵌套的列表前加四个空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 第一
    * hello
    * world
2. 第二
    * hah
    * lala
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613133748693-1945157290.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;类似的，要在列表中使用 引用 &lt;code&gt;&amp;gt;&lt;/code&gt; 的话，也需要加四个空格&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 第一
    &amp;gt; wocaosdfsdf
2. 第二
    &amp;gt; sodfjowgjeowejgo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613133952134-1854207904.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;p&gt;markdown 使用  &lt;strong&gt;&lt;em&gt;`&lt;/em&gt;&lt;/strong&gt;  语法标记代码，不过我们也经常用来标记文本。&lt;/p&gt;

&lt;h3 id=&#34;行代码&#34;&gt;行代码&lt;/h3&gt;

&lt;p&gt;如果代码比较短，或只有一句，使用两个  &lt;em&gt;`&lt;/em&gt; 标记代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`int a;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613134752963-562517882.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们发现这样标记代码语句很方便，我们有时候要强调一些文字词语或语句，也可以使用这个语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`这是一个强调语句`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613134940356-753742836.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;块代码&#34;&gt;块代码&lt;/h3&gt;

&lt;p&gt;我们要引入代码块的话，可以使用六个 &lt;em&gt;`&lt;/em&gt; 把代码快标记起来，在第一行后面可以加上是什么语言，不加也可以使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;​```
int main(void) {
	printf(&amp;quot;Hello world!&amp;quot;);
	
	return 0;
}
​```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613135211676-727242141.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;加上语言&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;​```c
int main(void) {
	printf(&amp;quot;Hello world!&amp;quot;);
	
	return 0;
}
​```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613135257924-151021262.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用代码块语法可以很方便的把使用一些代码，因为是原样引入的，所以我们有时也经常使用这个语法来引入一些文字，如要避免 &lt;code&gt;#&lt;/code&gt; 被解析为标题，就可以使用这个语法，这篇博客也是这么写的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;​```
# 这是标题语法
​```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613135701179-544335821.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;

&lt;p&gt;markdown 支持导入图片，不够并不支持更改图片的大小。&lt;/p&gt;

&lt;h3 id=&#34;普通-1&#34;&gt;普通&lt;/h3&gt;

&lt;p&gt;可以直接导入图片，使用  &lt;code&gt;![]()&lt;/code&gt; 语法， &lt;code&gt;[]&lt;/code&gt; 中放图片的 alt 属性，也就是移动鼠标到图片上会出现的文字，&lt;code&gt;()&lt;/code&gt; 类放图片的链接，可以是外链，也可以是本地的绝对地址或相对地址。同时 &lt;code&gt;()&lt;/code&gt; 里在链接后还可以使用 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 或 &lt;code&gt;&#39;&#39;&lt;/code&gt; 给图片加上 title 属性。&lt;/p&gt;

&lt;p&gt;使用外链，没加 alt 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![](https://user-gold-cdn.xitu.io/2018/4/18/162d75d959444389?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613162018418-91728471.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;加 alt 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![这是一张美景](https://user-gold-cdn.xitu.io/2018/4/18/162d75d959444389?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加 title&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Alt text](/path/to/img.jpg &amp;quot;Optional title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![](/home/edte/pictures/631739.jpg)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;引用-1&#34;&gt;引用&lt;/h3&gt;

&lt;p&gt;同时如果我们要在多个地方导入同一张图片的话，可以把图片链接单独拿出来，然后给它加一个 id，要使用这张图片直接使用这个 id。引用图片时的语法 &lt;code&gt;![][]&lt;/code&gt;, 第一个 &lt;code&gt;[]&lt;/code&gt; 里加 alt 属性，第二个加图片 id，而给图片加 id 的语法是 &lt;code&gt;[]: url title&lt;/code&gt; ，主要 &lt;code&gt;:&lt;/code&gt; 后要加空格，后面的内容和直接使用图片时 &lt;code&gt;()&lt;/code&gt; 的内容一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![][id]

[id]: https://avatars2.githubusercontent.com/u/3265208?v=3&amp;amp;s=100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;amp;s=100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果一样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613163039691-882959907.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;超链接&#34;&gt;超链接&lt;/h2&gt;

&lt;p&gt;markdown 支持超链接，可以直接放 URL，也可以文字链接，图片链接。&lt;/p&gt;

&lt;h3 id=&#34;直接链接&#34;&gt;直接链接&lt;/h3&gt;

&lt;p&gt;markdown 支持直接放链接，使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 把 URL 围起来即可, 一般这么直接放邮箱地址或一些比较短的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;http://www.baidu.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613160729650-1797553202.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example@email.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613161044489-662208021.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;文字链接&#34;&gt;文字链接&lt;/h3&gt;

&lt;p&gt;我们可以添加文字链接，也就是点击文字跳转到目标地址。语法 &lt;code&gt;[]()&lt;/code&gt;,  &lt;code&gt;[]&lt;/code&gt; 内放文字，&lt;code&gt;()&lt;/code&gt; 里放目标链接，如果不放的话，根据具体的渲染不同，有的会默认刷新当前链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是 [百度](https://www.baidu.com) 的链接
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613163842235-1519003886.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，类似引入图片，如果我们要跳转的文字链接相同的太多了，也可以把它弄成一个 id 去引用，语法 &lt;code&gt;[][]&lt;/code&gt;,  第一个 &lt;code&gt;[]&lt;/code&gt; 里放文字，第二个放 id，然后再用 &lt;code&gt;[]: url&lt;/code&gt; 定义url 的 id。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[百度][id]

[id]: https://www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613164233274-325213845.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;图片链接&#34;&gt;图片链接&lt;/h3&gt;

&lt;p&gt;markdown 也支持图片链接，也就是点击图片跳转链接，这个其实就是文字链接和引入图片的结合。文字链接的语法是 &lt;code&gt;[]()&lt;/code&gt;, 所以只要在第一个 &lt;code&gt;[]&lt;/code&gt; 里把文字变为图片就是图片链接，而图片是 &lt;code&gt;![]()&lt;/code&gt;, 所以图片链接就是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[![图片 alt](图片 url)](跳转的 url)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[![](https://cdn.sspai.com/attachment/origin/2014/04/15/69530.png?imageMogr2/auto-orient/quality/95/thumbnail/!1420x708r/gravity/Center/crop/1420x708/interlace/1)](https://zh.wikipedia.org/wiki/Markdown)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613164756533-545661439.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;

&lt;p&gt;表格的语法比较复杂，使用 &lt;code&gt;|&lt;/code&gt; 分割单元格，用 &lt;code&gt;-&lt;/code&gt; 分割表头和其他行，用 &lt;code&gt;:&lt;/code&gt; 表示对齐。&lt;/p&gt;

&lt;p&gt;这是没有对齐的，默认表头居中，表格左对齐&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|    name    | age |
| ---------- | --- |
| LearnShare |  12 |
| Mike       |  32 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613170757327-1505343819.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:---&lt;/code&gt; 代表左对齐，&lt;code&gt;:--:&lt;/code&gt; 代表居中对齐，&lt;code&gt;---:&lt;/code&gt; 代表右对齐&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| left | center | right |
| :--- | :----: | ----: |
| aaaa | bbbbbb | ccccc |
| a    | b      | c     |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613171012952-890986657.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表格中也支持其他 markdown 语法，如文字链接，字体等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|     name     | age |             blog                |
| ------------ | --- | ------------------------------- |
| _LearnShare_ |  12 | [LearnShare](http://xianbai.me) |
| __Mike__     |  32 | [Mike](http://mike.me)          |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613171309403-546628364.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;水平分割线&#34;&gt;水平分割线&lt;/h2&gt;

&lt;p&gt;markdown 也支持分割线，在一行连续使用三个 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 即可，之间可以加空格&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** 
---
___
* * *
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;p&gt;有些解析器支持添加目录（Table of Contents），如 github，直接在前面加上 &lt;code&gt;[toc]&lt;/code&gt; 即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[toc]

## 一级标题

## 二级标题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613172924841-1888403180.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;删除线&#34;&gt;删除线&lt;/h2&gt;

&lt;p&gt;有些解析器支持删除线，自己在目标文字间加上两个 &lt;code&gt;~&lt;/code&gt;即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~~我被删除啦~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202006/1823594-20200613173328031-272060208.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;基础的语法已经足够使用，而那些专业点的图，如流程图之类的还是使用专业的工具来画比较好，使用 markdown 的目的是让我们专注于内容本身，而复杂的语法和不兼容的特性会大大降低我们效率。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Markdown 中文文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Markdown&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;markdown&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://xianbai.me/learn-md/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Learning-Markdown&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/markdown/md-tutorial.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Markdown 教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://mazhuang.org/2018/09/06/markdown-intro/#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一份简明的 Markdown 笔记与教程&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈数据结构与算法</title>
      <link>https://edte.github.io/2020/2020-06-11-%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-11-%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;这篇文章是我阅读《大话数据结构》前两章，和阅读相关一些博客的学习笔记总结，主要介绍一下数据结构和算法是什么，有什么用。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在介绍数据结构之前，我们先来介绍一些前置知识，因为计算机的专业词汇都是英文的，我们又是第一次接触这个词汇，而对其进行翻译经常会造成一些理解上的偏差和误导，所以我尽量在涉及专业词汇时使用英文词汇。&lt;/p&gt;

&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;

&lt;h3 id=&#34;data&#34;&gt;data&lt;/h3&gt;

&lt;p&gt;计算机只能存储二进制文件，这是我们都知道的，因为硬件上的构造所致，所以计算机最终处理的一些信息都是二进制文件。就这么说可能不怎么容易理解，我们来实际看一下吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 新建文件
touch a.c
// 编辑
vim a.c
//输入
#include &amp;lt;stdio.h&amp;gt;
int main(void) {
    printf(&amp;quot;hello world&amp;quot;);
    return 0;
}
// 编译
gcc a.c -o b
// 执行
./b          // 输出 hello world, 说明我们编译成功了
// 查看二进制文件，使用 xxd 命令，输出十进制
xxd -b b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果成功了，我们会看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0000403e: 00000000 00000000 00000001 00000000 00000000 00000000  ......
00004044: 00000000 00000000 00000000 00000000 00000000 00000000  ......
0000404a: 00000000 00000000 00000000 00000000 00000000 00000000  ......
00004050: 00010001 00000000 00000000 00000000 00000011 00000000  ......
00004056: 00000000 00000000 00000000 00000000 00000000 00000000  ......
0000405c: 00000000 00000000 00000000 00000000 00000000 00000000  ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以清晰的看到，二进制文件的确是 0 1 组成的。那么对于计算机都是些 0 1, 那我们人类该怎么对待这些 0 1 呢？&lt;/p&gt;

&lt;p&gt;或许我们该思考一下，我们发明计算机是为了什么，我们每天都在使用计算机，手机，电梯，冰箱。。真如同我们思考物理的未来一样，我们去探索这些并不是为了真理，而是为了解决我们所遇到的实际的问题。那么要解决问题，就要模拟实际问题，然后再是解决问题。所以计算机就面对着一个很重要的任务：输入信息，处理信息，输出信息。信息，也就是我们要讲的 data。&lt;/p&gt;

&lt;p&gt;我们刚刚说了计算机只能存放和处理二进制信息，而又面临则模拟世界的重任，而我们这个世界也是又小小的原子组成许多不同类型的分子，然后又组成各种各样的东西，最终形成了我们现在的世界，所以我们同样需要使用这些二进制来创造一些 type, 也就是 data type，来作为一些基础来模拟现实。&lt;/p&gt;

&lt;h3 id=&#34;data-type&#34;&gt;data type&lt;/h3&gt;

&lt;p&gt;我们刚刚引入了 data type 的必要性，现在我们就来谈谈它们在具体的语言中的实现。我们知道计算机都是二进制存储的，所以在早期编程人员们也只能输出输出二进制数据，也就是使用机械语言。慢慢的人们发现有一些操作是经常做的，所以为了提高效率，把一些常用的操作简写成一些字母，然后使用这些字母来经常编程，这些字母就是汇编语言。但是我们知道这些语言都是直接和机器打交道的，让我们这些使用自然语言交流的人很不容易理解，所以为了便于人们能够理解，就慢慢出现了一些模仿自然语言的高级语言，如同 c 语言，这之后又出现许多编程范式，创建了许多语言，有着各种各样的应用场景。&lt;/p&gt;

&lt;p&gt;我们简要知道了语言的发展，而现在我们一般都使用高级语言与机器交互，我们又说了机器要模拟实际，所以高级语言一般都内置了一些基本的 data type, 正如同英语有 26 个字母一样，有些类型是不可分割的，而又如同我们可以自由使用字母组合新单词，我们也可以使用各种 data type 来组成其他的 type。&lt;/p&gt;

&lt;p&gt;具体到高级语言，如有 int, bool, float, char，num, pointer 这些不可分割的基础 type，也有在不同机器上体现差距的 int32,int64 等等。也有 array, struct, map 等多个 type 组合类型。&lt;/p&gt;

&lt;h3 id=&#34;abstract-data-type&#34;&gt;abstract data type&lt;/h3&gt;

&lt;p&gt;我们刚刚明白了 data type 是怎么来的，现在我们来讲一下 data type 中比较常见的一个概念。我们说过，语言中的基本 type 可以由其他的 type 注册，那么当我们使用一个 type 时，这个 type 背后的原理都是对我们来说是不可见的，这个 type 就可以说是 abstract 的，我们使用计算机模拟这个时间，比如现在要模拟一个学生，我们可能会定义一个学生类，然后给它声明一些变量属性，给它加一些动作方法，但我们操作这个学生类时，这个 type 既在原理上对我们来说是封装好的，用这种模拟的方式来模拟现实中的事务，这也是一种抽象，我们也可以说这个 type 是 abstract 的，所以无论是从存储的原理来说，还是模拟现实来说，任何 type 都是 abstract 的，所以可以说每个 data type 都是 abstract data type(ADT).&lt;/p&gt;

&lt;h3 id=&#34;type-system&#34;&gt;type system&lt;/h3&gt;

&lt;p&gt;我们现在应该能够理解 data type 在一门语言中的地位了，而实际在一门语言中怎么设计，就要看 type system 这门学科了。我们在这里简单介绍一下。 type system 就如同 operation system, file system 一般，是具体研究某门知识的学科，这里就是研究在语言中 type 怎么设计，怎么存储，怎么运用，怎么检查，怎么转换等知识。&lt;/p&gt;

&lt;p&gt;我们作为普通的程序猿，一般接触到得比较多的就是 type declaration, type checking 和 type conversion 相关的知识了。&lt;/p&gt;

&lt;p&gt;比如我们使用在 c 中，要声明一个变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要显式的表明这个类型是什么，而在 type 中，我们则可以不显式的声明，编译器会根据赋值的内容去自动推断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了不同的 type, 那么计算机也需要检查 type 对不对，我们知道一般的软件构建过程是 编写(edit) -&amp;gt; 编译(compile) -&amp;gt; 链接(link) -&amp;gt; 装载 -&amp;gt; 运行(run)&lt;/p&gt;

&lt;p&gt;而一般 type checking 发生在 compile 或 run 期间。发生在 complie 的就叫 Statically checked language，而发生在 run 期间的就叫 Dynamically checked language。像 js, python,php 就是动态语言，而 c，java,c++ 等就是静态语言。&lt;/p&gt;

&lt;p&gt;除了 type checking 外，type conversion 也是我们经常遇见的，一般对那些 type checking 限制比较弱，可以隐式的类型转换的语言，我们叫 Weakly checked language，比如 c, python, js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a;
a = &#39;b&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种直接不同 type 间可以直接 convert ，具体的转换过程由编译器自己做。&lt;/p&gt;

&lt;p&gt;而一般对那些 type checking 限制比较强，需要显式的类型转换的语言，我们叫 Strongly checked language，比如 go, java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a int
a = &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样直接转换会报 error，需要使用特殊的函数才行。 type system 是一门庞大的学科，这里只是简单介绍一下，要深入学习还需要读更多的书，做更多的实践。&lt;/p&gt;

&lt;h3 id=&#34;data-structure&#34;&gt;data structure&lt;/h3&gt;

&lt;p&gt;我们前面讲了 data type 的来由，我们一般直接就拿不同 type 的 data 开始干活，比如直接声明个 int a 就开始赋值判断什么的，但是我们也知道，除了直接使用 data 做事外，data 间也有一些关系，这就是我们要讲的 data structure.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;逻辑结构(Logical  structure)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们先来讲一下 data 间在逻辑上有哪些结构，就像我们中学学过的函数图像一样，data 间有线性结构(linear structure) 和非线性结构(nonlinear structure) 这两种。&lt;/p&gt;

&lt;p&gt;线性结构(linear structure) 的我们一般叫线性表(Linear list)，data 间一个连着一个，一对一的关系，就是 linear list ，而没有 data 的 linear list 我们一般叫空表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mubu.com/document_image/5a4b6a6e-dff2-4608-96bc-77a924fac8fa-3051986.jpg&#34; alt=&#34;linear list&#34; /&gt;&lt;/p&gt;

&lt;p&gt;非线性结构(nonlinear structure) 有树(Tree), 图(Graph) 这两种。&lt;/p&gt;

&lt;p&gt;data 前面最多连接一个，后面可以连接多个的叫 tree, 讲究 data 间一对多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mubu.com/document_image/7f8cad6a-31f2-40e8-9193-47d0e8a52b41-3051986.jpg&#34; alt=&#34;tree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;data 前面后面都可以连接多个的，我们叫 graph, data 间是多对多的关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mubu.com/document_image/c0f99e81-3222-4fe4-8575-04e5e924cd49-3051986.jpg&#34; alt=&#34;tree&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;物理结构（phyical structure）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;data 间从逻辑上来说就只有上面那三种关系，现在我们来看一下 data 间物理上的关系，我们知道 data 都是要存在存储介质上的，一般我们说的是内存，所以 data 在物理上的关系就是在内存上是什么关系。所以物理结构也叫存储结构。&lt;/p&gt;

&lt;p&gt;在物理上存储，两个 data 只有两种情况，相连或不相连，所以对于多个 data 来说也只有两种情况，顺序存储结构和链式存储结构。&lt;/p&gt;

&lt;p&gt;顺序存储结构：data 在内存（或其他存储载体）上，连续分配内存空间，要查询下一个 data，只需查看下一个内存单元地址的 data 即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mubu.com/document_image/b9a920bc-1728-4c8c-b0dd-c4b34c11e9e4-3051986.jpg&#34; alt=&#34;顺序存储结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;链式存储结构：data 在内存单元生分布没有规律，因此要查询逻辑上的下一个 data，需要知道下一个 data 在哪，于是需要知道下一个 data 的内存地址，就会在这个 data 的地方存放下一个 data 的内存地址，也就是指针。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mubu.com/document_image/0987f1e7-fdea-4404-bce6-c377ed05532d-3051986.jpg&#34; alt=&#34;链式存储结构&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;data 的 structure 其实就只有上面这些情况，其他的结构都只是这上面的推广。如逻辑上线性的 data 如果在物理上也线性，也就是连续分配内存空间，那就是顺序表，我们常使用的 string, array,slice 其实就是顺序表中的一种，如果逻辑上线性的 data 如果在物理上非线性，那就是链表。我们常说的栈则是限定仅在表尾进行插入和删除操作的线性表。队列则是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。还有我们常说的二叉树也只是只有两个分支的 tree, 堆则是一种特殊二叉树等等。&lt;/p&gt;

&lt;p&gt;理解了 data 间的关系，再具体去学习的时候就能比较容易的理解一些数据结构的性质，比如因为线性表在内存上连续分配，所以可以根据首地址和偏移量拿到每个 data 的地址，所以线性表的查询算法时间复杂度是 O(1), 同样理解了基础的结构之后，对于一些新的，未知的数据结构也能知道大概是什么样的，比如以前可能完全没有听说过队列，但是如果说它是个特殊的线性表，那就更容易理解些。&lt;/p&gt;

&lt;h3 id=&#34;algorithm&#34;&gt;algorithm&lt;/h3&gt;

&lt;p&gt;我们现在从 data 开始，一直说道了 data structure, 不要完了我们为什么要说这些。回想一下，我们为什么要去学习 data 呢，因为这是计算机对信息的表达，和处理方式，那我们为什么要去学习计算机呢，你可能还记得，我们学习计算机不是为了追求真理，而是为了解决现实中，我们实际遇到的问题，而算法（algorithm）就是这么一个东西，算法就是解决问题的方法。&lt;/p&gt;

&lt;p&gt;算法是一种抽象的概念，只要能够解决一个问题，那它就是一个算法，而在计算机中是使用指令来执行命令的，所以算法是又一些指令组成，能够解决 问题的指令级。我们理解为步骤就行了，比如一个经典的问题：怎样才能把一头大象装进冰箱？&lt;/p&gt;

&lt;p&gt;我们现在有问题：怎样才能把一头大象装进冰箱，然后要给出这个问题的方法，也就是算法的话，这里有一个很经典的回答&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 把冰箱门打开
2. 把大象装进去
3. 把冰箱门关上
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们解决了问题（怎样才能把一头大象装进冰箱），又是一些步骤（指令）的集合，所以这就是一个算法。&lt;/p&gt;

&lt;p&gt;一般一个问题不只一个算法，比如刚刚这个问题，我们可以把大象切成肉片（orz), 然后再打开冰箱把它装进去，这也是一个算法，不同算法间也有效率高低之分，这个我们等会再说。&lt;/p&gt;

&lt;p&gt;我们刚刚也没有说要使用怎样的语言来解决这个问题，我们可以用自然语言，可以用伪代码，也可以用其他高级语言，这并不是一个需要过于担心的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;算法的特性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们引入了算法是什么，来看一下比较规范的定义吧&lt;/p&gt;

&lt;p&gt;输入输出：可以没有输入，但是需要有输出参数，可以是打印，或者返回值 有穷性：执行有限的步骤，在可接受的时间内完成&lt;/p&gt;

&lt;p&gt;确定性：每个步骤都没有二义性，都有明确唯一的意义&lt;/p&gt;

&lt;p&gt;可行性：算法可以转换为程序上机运行，并得到正确的结果&lt;/p&gt;

&lt;p&gt;算法要有输入输出，要每个步骤都有明确的意义，要在可以接受的时间内完成，要可以实际用语言实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;算法设计的要求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正确性：算法能够成功解决问题，没有语法错误和语义错误&lt;/p&gt;

&lt;p&gt;可读性: 算法可读性高，人们便于理解&lt;/p&gt;

&lt;p&gt;健壮性：对不合法输入能够做出处理&lt;/p&gt;

&lt;p&gt;效率： 时间复杂度低，算法花的时间少&lt;/p&gt;

&lt;p&gt;占用内存： 空间复杂度低，算法占用的内存少&lt;/p&gt;

&lt;p&gt;算法要没有语法、语义错误，能成功解决问题，要便于人们理解，对于不合法输入能够正确处理，花费时间和内存少，效率高。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;算法效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们说了一个问题可以有不同的算法，那么怎么判定一个算法的好坏就很重要，也就是怎么判断一个算法效率的高低。&lt;/p&gt;

&lt;p&gt;一个算法要执行的话，会花费空间（占用内存）（空间复杂度），时间（时间复杂度），以前的内存价格高，现在我们对内存的要求没有那么高了，所以一般只看花费的时间，但是如何看花费了多少时间呢？&lt;/p&gt;

&lt;p&gt;事后统计：算法写完之后，通过测试大量数据看 run 的时间来比对效率，这种方法对硬件的要求，软件的要求，问题规模等要求比较高，而且作为统计数据，从科学上没有那么科学&lt;/p&gt;

&lt;p&gt;事前分析：通过判断执行语句的次数，来统计估量时间复杂度，需要测试的数据越多，次数的变化会体现出算法的效率&lt;/p&gt;

&lt;p&gt;一般来说就这么两种方法，我们知道实际算法的效率&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;计算机执行每条指令的速度 -&amp;gt; 硬件层面
编译产生的代码质量 -&amp;gt; 软件层面
算法的好坏 (算法使用的策略)
问题规模
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事后统计要四个都要看，而事前分析只需要看算法的好坏和问题规模，所以要实际测量算法效率，事前分析比较好。但是只是分析的话，又不能实际 run 一下看消耗时间，所以可以用实际执行的语句次数来表示，这样能用数学证明算法的效率优劣。要使用实际执行的语句次数来表示时间，这里就要引入时间复杂度的概念&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;公式：T(n) = O(f(n))
n: 问题规模
f(n): 执行指令次数
T(n): 时间复杂度
O () ：一种运算方式，作用就是去除其他项，包括与最高项相乘的常数，只保留最高项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如这个算法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i;      // 1 此
for(i = 0 ; i &amp;lt; n ; i++){        // 1 次
    println(i);  // n 次
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先别管这个算法有什么用，我们来看 f(n)=n+2, T(n) = O(n+2) = O(n)&lt;/p&gt;

&lt;p&gt;所以这个算法的时间复杂度为 O(n), 要具体学习怎么表达时间复杂度可以自己找其他书籍学习。&lt;/p&gt;

&lt;p&gt;常见实际复杂度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; O(1)&amp;lt;O(logn)&amp;lt;O(n)&amp;lt;O(nlogn)&amp;lt;O(n2)&amp;lt;O(n3)&amp;lt;O(2n)&amp;lt;O(n!)&amp;lt;O(nn) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他还有 最坏/最好/平均时间复杂度 的概念，一个算法通常花费的时间复杂度不同，我们来具体实际例子吧。&lt;/p&gt;

&lt;p&gt;假设你上次交的作业 发下来了，现在要在 n 本书中找到你的那本书。 问题规模就是 n。&lt;/p&gt;

&lt;p&gt;假设我们使用这种算法：（遍历）一本一本的查。那测试数据就是 1。&lt;/p&gt;

&lt;p&gt;最好的情况就是第一本就找到了，那么执行语句就是 1, 时间复杂度就是 O(1)，这就是最好时间复杂度。&lt;/p&gt;

&lt;p&gt;最坏的情况就是最后一本才是，那么执行语句就是 n，时间复杂度就是 O(n) ，这就是最坏时间复杂度。&lt;/p&gt;

&lt;p&gt;平均的情况要复杂些，这里就不说了。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我们从计算机的目的讲了 data 的发展，然后引出了数据结构，之后我们从又计算机的目的出发，引入了算法的一些概念。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/19918532&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;弱类型、强类型、动态类型、静态类型语言&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/40ea3e19605b#2.1.%20%E6%95%B0%E6%8D%AE&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;计算机常用英语词汇 —— 数据结构与算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/21387264&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;如何理解算法时间复杂度的表示法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20196775&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;如何清晰的理解算法中的时间复杂度？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/6424904/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;大话数据结构&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go builtin 包讲解</title>
      <link>https://edte.github.io/2020/2020-06-09-go-builtin-%E5%8C%85%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Tue, 09 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-09-go-builtin-%E5%8C%85%E8%AE%B2%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;这篇博客记录一下我学习 builtin  包的一些历程&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;我们知道，一门语言中的函数有两种类型，即内置函数和标准库函数，内置函数在直接内置在编译器中，而标准库则在磁盘里，需要用时需要去寻找。在 go 中也是一样，严格说来并没有 builtin 这个标准库，而我们现在在学习的这个包，只是官方为了使用 go doc 工具方便生成文档，而常见的，这个包里都是对 go 语言预定义标识符的一些介绍，具体实现自然没有在这个包。我们看源码包注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
	Package builtin provides documentation for Go&#39;s predeclared identifiers.
	The items documented here are not actually in package builtin
	but their descriptions here allow godoc to present documentation
	for the language&#39;s special identifiers.
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里清楚的说明了这个包的作用，所以我们平时使用 &lt;code&gt;errors.new&lt;/code&gt; &lt;code&gt;new&lt;/code&gt; 等，明明是小写，但是却可以在任何包中使用，这是因为它们根本就不是标准库函数，是内置函数。&lt;/p&gt;

&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;

&lt;h3 id=&#34;bool-true-flase&#34;&gt;bool/true/flase&lt;/h3&gt;

&lt;p&gt;我们知道任何语言都有一些数据类型（data type），而 bool 正是 go 内置的其中一种。&lt;/p&gt;

&lt;p&gt;在 go 中，任何 data 都是分为 type 和 value 的，在 go 中还专门有 reflect 包来提供这方面的功能。对于 bool 这种 type, 也是有其 value 范围的，在 go 中就是  true 和 false 这两种了。在 go 里，true 和 false 都是常量，具体实现我们看源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bool is the set of boolean values, true and false.
type bool bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 bool 是一种 type, value 是 true 和 false。我们可以实际来建立一个 bool var 看看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var a bool

	fmt.Println(reflect.TypeOf(a))  // bool
	fmt.Println(reflect.ValueOf(a)) // false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现如果不在声明的时候赋值的话，bool 默认的 value 是 false&lt;/p&gt;

&lt;p&gt;我们再来看源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// true and false are the two untyped boolean values.
const (
	true  = 0 == 0 // Untyped bool.
	false = 0 != 0 // Untyped bool.
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，true 和 false 是两种 const, 同时作为 bool type 的 values, 至于为什么 是 &lt;code&gt;0 == 0&lt;/code&gt; 这种表达，或许你需要了解一下 bool 这种类型是什么意思。&lt;/p&gt;

&lt;p&gt;我们可以实际看一下 true 和 false 的 type 和 value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(reflect.TypeOf(true))  // bool
	fmt.Println(reflect.ValueOf(true))  // true
	fmt.Println(reflect.TypeOf(false))  // bool 
	fmt.Println(reflect.ValueOf(false))  //false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们说了这个包里都是些预定义标识符，不是关键字，那么我们可以把这些作为标识符的名字，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var true int

	true = 1
	fmt.Println(true) // 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 true 是能作为标识符的名字的，但是这种命名是极不推荐的，后面就的同样道理，就不占开了。&lt;/p&gt;

&lt;h3 id=&#34;uint8-uint16-uint32-uint64-uint-uintptr&#34;&gt;uint8/uint16/uint32/uint64/uint/uintptr&lt;/h3&gt;

&lt;p&gt;我们只看 int 类型是基本的 data type，之后我们就会讲到 int，同样在 go 中，加上前缀 u (unsigned), 表示无符号整数，加上数字表示这个 int 占用多少 bit，如 uint32, 表示无符号整数，占用 32 bit。&lt;/p&gt;

&lt;p&gt;我们来看源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// uint8 is the set of all unsigned 8-bit integers.
// Range: 0 through 255.
type uint8 uint8

// uint16 is the set of all unsigned 16-bit integers.
// Range: 0 through 65535.
type uint16 uint16

// uint32 is the set of all unsigned 32-bit integers.
// Range: 0 through 4294967295.
type uint32 uint32

// uint64 is the set of all unsigned 64-bit integers.
// Range: 0 through 18446744073709551615.
type uint64 uint64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到讲了这些 type，以及它们的范围（range），我们刚刚说了，后缀数字表示占用的 bit，比如占用 8 bit，那么就可以表示  &lt;code&gt;2 ** 8&lt;/code&gt; 种情况。&lt;/p&gt;

&lt;p&gt;我们来输出看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(math.Pow(2, 8))   // 256
	fmt.Println(math.Pow(2, 16))  // 65536
	fmt.Println(math.Pow(2, 32))  // 4.294967296e+09
	fmt.Println(math.Pow(2, 64))  // 1.8446744073709552e+19
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 range 的上限就是这么来的，至于下限，都说了 unsigned 的了，自然只能是整数，如果你对这些不了解的话，需要自行了解一下它们的存储原理。&lt;/p&gt;

&lt;p&gt;我们知道 uint 是有范围的，在 c 中，溢出（overflow）了的话，会根据存储原理改变数值，而不会报错，那么 go 中会怎么办呢，我们来看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var u uint8  // (0,255)
	u = -1   // constant -1 overflows uint8
	fmt.Println(u)
	u = 300   // constant 300 overflows uint8
	fmt.Println(u)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，go 会报 error ，这让我们更加关注问题本身，而不用考虑语言带来的问题了。&lt;/p&gt;

&lt;p&gt;我们发现包中还有一个 uint 类型，前缀容易理解了，但是却没有后缀，我们来看注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// uint is an unsigned integer type that is at least 32 bits in size. It is a
// distinct type, however, and not an alias for, say, uint32.
type uint uint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来这是一个动态的 uint，我们经常会遇到移植问题，在不同平台上使用的 bit 也不同，所以这个类型可以很方便的自动判断，当使用 32 bit 的平台，那么就是 32 bit 的，当使用 64 bit 的，那么就是 64 bit 的。最小 32 bit，没有 8 和 16 bit 的。&lt;/p&gt;

&lt;p&gt;我们继续，我们发现还有一个 uint 开头的 uintptr, uint 我们理解了， ptr 又是什么玩意？回想一下，  ptr 好像是 pointer(指针) 的缩写，那么这个类型肯定和 pointer 有关，我们继续看注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// uintptr is an integer type that is large enough to hold the bit pattern of
// any pointer.
type uintptr uintptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来这个 type 也是一种 unsigned int, 用来存指针，至于有什么用，博主的指针现阶段比较弱，还没遇到过。&lt;/p&gt;

&lt;h3 id=&#34;int8-int16-int32-int64-int&#34;&gt;int8/int16/int32/int64/int&lt;/h3&gt;

&lt;p&gt;我们前面讲了 uint，这里讲解 int，没有了 u 前缀，我们容易理解 int 表示一一般的 int 型，对于 unsigned int 的范围是正数，而 int 型则根据其存储方式范围有正有负，后面的数字同样表示其占的 bit 数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// int8 is the set of all signed 8-bit integers.
// Range: -128 through 127.
type int8 int8

// int16 is the set of all signed 16-bit integers.
// Range: -32768 through 32767.
type int16 int16

// int32 is the set of all signed 32-bit integers.
// Range: -2147483648 through 2147483647.
type int32 int32

// int64 is the set of all signed 64-bit integers.
// Range: -9223372036854775808 through 9223372036854775807.
type int64 int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(math.Pow(2, 8) / 2)  //128
	fmt.Println(math.Pow(2, 16) / 2)  //32768
	fmt.Println(math.Pow(2, 32) / 2)  //2.147483648e+09
	fmt.Println(math.Pow(2, 64) / 2) //9.223372036854776e+18
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到其范围是对上的，不知道怎么回事请先学习 int 的存储方式。&lt;/p&gt;

&lt;p&gt;我们再来看 int 型，类似于 uint&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// int is a signed integer type that is at least 32 bits in size. It is a
// distinct type, however, and not an alias for, say, int32.
type int int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类型同样是一个不定的类型，根据平台知道分配 32 或 64 bit。&lt;/p&gt;

&lt;h3 id=&#34;float32-float64&#34;&gt;float32/float64&lt;/h3&gt;

&lt;p&gt;我们继续来看 float&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// float32 is the set of all IEEE-754 32-bit floating-point numbers.
type float32 float32

// float64 is the set of all IEEE-754 64-bit floating-point numbers.
type float64 float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 float32/float64 即遵从 IEEE-754 标准的常用的单精度/双精度浮点数，类似 c 中的 float 和 double，至于 float 是什么，IEEE-754 标准是什么，这里就不展开了。&lt;/p&gt;

&lt;h3 id=&#34;complex64-complex128&#34;&gt;complex64/complex128&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// complex64 is the set of all complex numbers with float32 real and
// imaginary parts.
type complex64 complex64

// complex128 is the set of all complex numbers with float64 real and
// imaginary parts.
type complex128 complex128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看注释我们知道 complex 是复数类型，并且虚数和实数要是同一种 type，go 里只有两种，虚数和实数是 float32 的建立 complex64 type，虚数和实数是 float64 的建立 complex128 type，数字就是虚数和实数的 bit 相加，比较容易理解。&lt;/p&gt;

&lt;h3 id=&#34;byte-rune&#34;&gt;byte/rune&lt;/h3&gt;

&lt;p&gt;我们先来看 byte&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 byte 即是 uint8, 只是用 type 别名了一下，uint8 我们先前知道即是无符号整型，占 8 bit，即 1 byte，也就是 1 字节，我们知道 byte 在计算机中是一个基本单位，那么 alias 一下便于使用也能理解，但是 rune 又是什么玩意？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到 rune 是 int32 的别名，也就是 4 byte, 为什么要单独把这个东西列出来呢？注释说是为了区分 char 和 int 型。这里显然需要具体了解 string, char，字符编码等底层知识，这里就不展开了。&lt;/p&gt;

&lt;h3 id=&#34;string&#34;&gt;string&lt;/h3&gt;

&lt;p&gt;我们来继续讲解 string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// string is the set of all strings of 8-bit bytes, conventionally but not
// necessarily representing UTF-8-encoded text. A string may be empty, but
// not nil. Values of string type are immutable.
type string string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 string 是 8 bit 的 slice, 也就是 byte slice, 使用的是 UTF-8 编码，只读，可以是空字符串，但不能是 nil, 我们来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := &amp;quot;&amp;quot;

	fmt.Println(reflect.TypeOf(a))   //string
	fmt.Println(reflect.ValueOf(a))  // 
	fmt.Println(len(a))      // 0 
	
	a = nil  //cannot use nil as type string in assignment
	
	a[0] = &amp;quot;sdf&amp;quot; //cannot assign to a[0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到的确可以为空字符串，其 byte length 为 0,输出空字符串，不能为 nil，且 string 这个 slice 是不能修改的。（len 返回 string 的 byte length)&lt;/p&gt;

&lt;p&gt;我们再看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := &amp;quot;啊&amp;quot;
	fmt.Println(len(a))  // 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道 中文在 Unicode 中占 2 byte，在 UTF-8 中 占 3 byte，可以看到的确是使用了 UTF-8 编码。但这也带来一些问题，比如如果某个字符串中有中文字符，想要获取这个字符串的字符个数，而不是 byte 长都，怎么办呢，显然 len 函数是不行的，又或者我们想要字符串的某个字符，直接使用下标 &lt;code&gt;a[3]&lt;/code&gt; 是不行的，这得到的是第几个 byte, 这些问题都是我们有时会遇到的，这里就不展开了，其实 rune 就可以在这种情况中使用。&lt;/p&gt;

&lt;h3 id=&#34;iota&#34;&gt;iota&lt;/h3&gt;

&lt;p&gt;我们发现 builtin 包中有个 iota 常量，如果稍微对 go 熟悉一点的话，就知道 strconv 包中也有个 itoa 函数，不过 strconv(string convert) 中的 itoa(int to ascii) 是 int 转 string 用的，这里的 iota 显然不一样。我们来看注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// iota is a predeclared identifier representing the untyped integer ordinal
// number of the current const specification in a (usually parenthesized)
// const declaration. It is zero-indexed.
const iota = 0 // Untyped int.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这个是一个常量计数器，只能在 const 语句中使用，默认从 0开始，后面递增赋值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(iota)  //undefined: itoa
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到我们不能直接使用 iota 常量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const a = iota

func main() {
	fmt.Println(a) // 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const (
	a = iota
	b
)

func main() {
	fmt.Println(a) // 0
	fmt.Println(b)  //1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const (
	a = iota
	b
)

const c = iota

func main() {
	fmt.Println(a) // 0
	fmt.Println(b) // 1
	fmt.Println(c) // 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上面我们知道 在不同的 const 语句中会重新从 0 开始，如果我们要跳过某个值的话，可以使用空白标识符 &lt;code&gt;_&lt;/code&gt; 占位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const (
	a = iota
	_
	b
)

func main() {
	fmt.Println(a) // 0
	fmt.Println(b) // 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const (
	a = iota
	_
	b
	c = 1
	d
	e
)

func main() {
	fmt.Println(a) // 0
	fmt.Println(b) // 2
	fmt.Println(c) // 1
	fmt.Println(d) // 1
	fmt.Println(e) // 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到如果某个值直接赋值了的话，后面会默认赋相同的值。&lt;/p&gt;

&lt;p&gt;这里我们大概讲解了 iota 的使用，当然还用具体实际的应用和一些注意点，这里就不展开了。&lt;/p&gt;

&lt;h3 id=&#34;type-type1-integertype-floattype-complextype&#34;&gt;Type/Type1/IntegerType/FloatType/ComplexType&lt;/h3&gt;

&lt;p&gt;这么一长串在 go 中都没有对应的预定义标识符，完全是为了生成文档，为什么要搞这几类，我们这里就不去了解了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Type is here for the purposes of documentation only. It is a stand-in
// for any Go type, but represents the same type for any given function
// invocation.
type Type int

// Type1 is here for the purposes of documentation only. It is a stand-in
// for any Go type, but represents the same type for any given function
// invocation.
type Type1 int

// IntegerType is here for the purposes of documentation only. It is a stand-in
// for any integer type: int, uint, int8 etc.
type IntegerType int

// FloatType is here for the purposes of documentation only. It is a stand-in
// for either float type: float32 or float64.
type FloatType float32

// ComplexType is here for the purposes of documentation only. It is a
// stand-in for either complex type: complex64 or complex128.
type ComplexType complex64
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nil&#34;&gt;nil&lt;/h3&gt;

&lt;p&gt;nil 是我们在错误处理时常遇到的，我们这里来稍微深入一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// nil is a predeclared identifier representing the zero value for a
// pointer, channel, func, interface, map, or slice type.
var nil Type // Type must be a pointer, channel, func, interface, map, or slice type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 nil 是一种 value，不是一种 type，这种 value 是 pointer, channerl, func, interface, map, slice 没有赋值时默认的 value。我们先来看这之外的 type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type A struct {
	i int
	f float32
	c complex64
	s string
}

func main() {
	var a A
	fmt.Println(reflect.ValueOf(a))  //{0 0 (0+0i) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到， int 为赋值时默认 value 为 0, float 为赋值时默认 value 为 0, complex 为赋值时默认 value 为 0+0i, string 为赋值时默认 value 为 &amp;ldquo;&amp;ldquo;。 struct 则要看具体的 filed，如果没有 filed 则 是 &lt;code&gt;{}&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := nil //Cannot use &#39;nil&#39; as type Type
	fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 nil 不是一种 type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(reflect.TypeOf(nil))  //&amp;lt;nil&amp;gt;
	fmt.Println(reflect.ValueOf(nil)) // &amp;lt;invalid reflect.Value&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这里 却显示 nil 是一种 type ，暂时不知道为什么。&lt;/p&gt;

&lt;p&gt;现在我们来看空 value 为 nil 的几种 type&lt;/p&gt;

&lt;p&gt;pointer&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var p *int

	fmt.Println(reflect.TypeOf(p))  //*int
	fmt.Println(reflect.ValueOf(p)) // &amp;lt;nil&amp;gt;
	fmt.Println(p == nil)  //true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;slice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var s []int

	fmt.Println(reflect.TypeOf(s))  //[]int
	fmt.Println(reflect.ValueOf(s)) // []
	fmt.Println(s == nil)  //true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;interface&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var a interface{}
	fmt.Println(reflect.TypeOf(a))  // &amp;lt;nil&amp;gt;
	fmt.Println(reflect.ValueOf(a)) //&amp;lt;invalid reflect.Value&amp;gt;
	fmt.Println(a == nil)           //true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var a map[int]string

	fmt.Println(reflect.TypeOf(a))  // map[int]string
	fmt.Println(reflect.ValueOf(a)) // map[]
	fmt.Println(a == nil)           // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var a chan int

	fmt.Println(reflect.TypeOf(a))  // chan int
	fmt.Println(reflect.ValueOf(a)) // &amp;lt;nil&amp;gt;
	fmt.Println(a == nil)           // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var a func()

	fmt.Println(reflect.TypeOf(a))  // func()
	fmt.Println(reflect.ValueOf(a)) // &amp;lt;nil&amp;gt;
	fmt.Println(a == nil)           // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们已经知道什么时候会出现 nil，那么具体 nil 的应用就要看具体哪一种类型了，如 error interface 为 nil 的话，就是没有错误，这也是我们最常用的一种，其他具体的应用这里就不展开了。&lt;/p&gt;

&lt;h3 id=&#34;complex-real-imag&#34;&gt;complex/real/imag&lt;/h3&gt;

&lt;p&gt;我们在前面讲了 complex 这种类型，但是要创建一个 complex 的话还需要借助 complex 这个内置 func&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The complex built-in function constructs a complex value from two
// floating-point values. The real and imaginary parts must be of the same
// size, either float32 or float64 (or assignable to them), and the return
// value will be the corresponding complex type (complex64 for float32,
// complex128 for float64).
func complex(r, i FloatType) ComplexType
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到传入两个 type 相同的 float，返回一个对于的 complexType, 如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	c := complex(1, 2)
	fmt.Println(reflect.TypeOf(c))   //complex128
	fmt.Println(reflect.ValueOf(c))  // 1+2i
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道复数是有实部（real) 和虚部（imaginary) 的，同样的，在 go 中也有 real(), ima() 函数获取对应的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The real built-in function returns the real part of the complex number c.
// The return value will be floating point type corresponding to the type of c.
func real(c ComplexType) FloatType

// The imag built-in function returns the imaginary part of the complex
// number c. The return value will be floating point type corresponding to
// the type of c.
func imag(c ComplexType) FloatType
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	c := complex(1, 2)
	fmt.Println(real(c)) // 1
	fmt.Println(imag(c)) // 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;append&#34;&gt;append&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// The append built-in function appends elements to the end of a slice. If
// it has sufficient capacity, the destination is resliced to accommodate the
// new elements. If it does not, a new underlying array will be allocated.
// Append returns the updated slice. It is therefore necessary to store the
// result of append, often in the variable holding the slice itself:
//	slice = append(slice, elem1, elem2)
//	slice = append(slice, anotherSlice...)
// As a special case, it is legal to append a string to a byte slice, like this:
//	slice = append([]byte(&amp;quot;hello &amp;quot;), &amp;quot;world&amp;quot;...)
func append(slice []Type, elems ...Type) []Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来看注释，注释说 append 用来给 slice 增加元素的，而且是在末尾追加。我们知道 slice 有 cap（分配的内存长度） 和 len（实际存储的元素个数），注释说，如果 cap 够，那么直接在这个 slice 中添加元素，如果不够，那么间新建一个 array。所以需要有一个返回值 slice。这里我们了解到，slice 其实底层就是 array，并不存在变长这么个操作，只是重新分配内存然后赋值而已。&lt;/p&gt;

&lt;p&gt;很多时候我们只是操作一个 slice, 所以一般都是把返回的 slice 赋给它本身，这样从结果看来似乎就是 slice 变长了。我们来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	b := append(a, 4, 5)
	fmt.Println(b) // [1 2 3 4 5]
	fmt.Println(a) // [1 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到原来的 slice a 并没有变化。&lt;/p&gt;

&lt;p&gt;当然更多的时候我们是这样用的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	a = append(a, 4, 5)
	fmt.Println(a) // [1 2 3 4 5]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们继续看注释，append 的第二个参数原来还可以是 slice, 我们来继续&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	b := []int{4, 5}
	fmt.Println(append(a, b...)) // [1 2 3 4 5]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现需要加 &lt;code&gt;...&lt;/code&gt;, 这个是 go 的一个语法糖，用来表示可变参数，这里就是把 b slice 中的元素以此传进去。&lt;/p&gt;

&lt;p&gt;当然，有时候我们会问如果类型不同怎么办&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	b := []string{&amp;quot;df&amp;quot;, &amp;quot;sd&amp;quot;}
	fmt.Println(append(a, b...)) //cannot use b (type []string) as type []int in append
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那当然是报 error 了。&lt;/p&gt;

&lt;p&gt;我们继续看注释，还有种特殊情况，第一个 slice 是 byte slice 时，第二个参数可以直接是 string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := append([]byte(&amp;quot;hello &amp;quot;), &amp;quot;word&amp;quot;...)
	fmt.Println(a)         // [104 101 108 108 111 32 119 111 114 100]
	fmt.Println(string(a)) // hello word
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现成功返回了 byte slice, 转换看一下也成功了，如果我们了解 string 的底层原理的话，我们就知道 string 其实就是 byte slice, 所以这种其实和第二个参数是 slice 原理相同，只是需要考虑是否会在字符编码的问题。&lt;/p&gt;

&lt;h3 id=&#34;copy&#34;&gt;copy&lt;/h3&gt;

&lt;p&gt;我们刚刚讲了 append() 这个给 slice 增加 elem 的 func，现在我们来继续讲一个和 slice 相关的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The copy built-in function copies elements from a source slice into a
// destination slice. (As a special case, it also will copy bytes from a
// string to a slice of bytes.) The source and destination may overlap. Copy
// returns the number of elements copied, which will be the minimum of
// len(src) and len(dst).
func copy(dst, src []Type) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们从注释中得知，这个函数用来复制 slice, 我们可能会问，为什么不直接声明一个变量赋值或短声明直接赋值呢，语言是苍白的，我们来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 3, 4, 5}
	var b []int
	b = a

	fmt.Printf(&amp;quot;%p\n&amp;quot;, a) // 0xc000100020
	fmt.Printf(&amp;quot;%p&amp;quot;, b)   // 0xc000100020
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 3, 4, 5}
	b := a

	fmt.Printf(&amp;quot;%p\n&amp;quot;, a) // 0xc000018240
	fmt.Printf(&amp;quot;%p&amp;quot;, b)   // 0xc000018240
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现两个 slice 的 地址是相同的，这说明它们根本指向的是一个东西，对一个操作会影响另一个变量。不行的话看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 3, 4, 5}
	b := a
	b[0] = 100

	fmt.Println(a[0]) //100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么这是为什么呢，如果我们知道 slice 的存储原理，或者学过 c 语言就比较容易理解，变量名存储的其实 slice 的首地址，直接赋值只是把首地址，也就是指针给传过去了，根本没有分配新的内存空间，自然会失败了。&lt;/p&gt;

&lt;p&gt;而 copy 函数，我们看到传入了 dst slice 和 src slice，即 目标（destination） slice 和 源（source） slice，分配了两块内存空间。我们知道有可能其中一个会溢出，所以会返回成功赋值成功的元素个数。我们来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	b := make([]int, 2)

	copy(b, a) // 把 a 的元素 复制 b，b 的 len 是 2 , a 是 3,所以 b 溢出了，只能复制前两个元素 1 和 2

	fmt.Println(b) // [1,2]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	b := make([]int, 5)

	copy(b, a) // 把 a 的元素 复制 b，b 的 len 是 5 , a 是 3,所以 a 的元素不够，剩余的元素不变，这里 int 型没有赋值是 0

	fmt.Println(b) // [1,2,3,0,0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{1, 2, 3}
	b := []int{10, 11, 12, 13, 14}

	copy(b, a)

	fmt.Println(b) // [1,2,3,13,14]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;delete&#34;&gt;delete&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// The delete built-in function deletes the element with the specified key
// (m[key]) from the map. If m is nil or there is no such element, delete
// is a no-op.
func delete(m map[Type]Type1, key Type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这个函数用于根据 key 删除 map 的 element。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := map[int]string{1: &amp;quot;ha&amp;quot;, 2: &amp;quot;Sdf&amp;quot;, 3: &amp;quot;gweg&amp;quot;}
	fmt.Println(a) //map[1:ha 2:Sdf 3:gweg]
	delete(a, 1)
	fmt.Println(a) // map[2:Sdf 3:gweg]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到成功删除成功，根据注释，可以知道当 map 为 nil，即没有给 map 赋值时，或者 key 不存在，那么什么也不做&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := map[int]string{1: &amp;quot;ha&amp;quot;, 2: &amp;quot;Sdf&amp;quot;, 3: &amp;quot;gweg&amp;quot;}
	fmt.Println(a) //map[1:ha 2:Sdf 3:gweg]

	delete(a, 0)   // key not exits
	fmt.Println(a) //map[1:ha 2:Sdf 3:gweg]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := make(map[int]string)
	fmt.Println(a) // map[]

	delete(a, 0)   // map nil  (equal key not exits)
	fmt.Println(a) // map[]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;len-cap&#34;&gt;len/cap&lt;/h3&gt;

&lt;h3 id=&#34;make-new&#34;&gt;make/new&lt;/h3&gt;

&lt;h3 id=&#34;close&#34;&gt;close&lt;/h3&gt;

&lt;h3 id=&#34;panic-recover&#34;&gt;panic/recover&lt;/h3&gt;

&lt;h3 id=&#34;prinln-print&#34;&gt;prinln/print&lt;/h3&gt;

&lt;p&gt;这是两个很少用的 func，但是既然出现了我们还是来看一下吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The print built-in function formats its arguments in an
// implementation-specific way and writes the result to standard error.
// Print is useful for bootstrapping and debugging; it is not guaranteed
// to stay in the language.
func print(args ...Type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，print 函数输出 stderr, 不像 fmt 包中 print 输出 stdout，在一些对这些有高亮显示的就能区分。同样 print 主要用于自举和 debug，而且还不一定保证以后不会去掉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The println built-in function formats its arguments in an
// implementation-specific way and writes the result to standard error.
// Spaces are always added between arguments and a newline is appended.
// Println is useful for bootstrapping and debugging; it is not guaranteed
// to stay in the language.
func println(args ...Type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 println 比 print 就是多了个在参数和新行后加空格，这些设计肯定是有其原因的，但是一般的开发者也用不了。这里简单的用代码讲解一下，以后该用 fmt 包就老老实实的用 fmt 包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := struct{}{}

	print(a) // illegal types for operand: print

	b := [10]int{}
	print(b) // illegal types for operand: print
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现这两个参数不能打印 struct 和 slice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a := []int{}

	println(a) // [0/0]0xc00003c778

	print(errors.New(&amp;quot;sdf&amp;quot;)) // (0x48a7c0,0xc00003c768)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打印组合型的参数时，打印底层的地址，而 fmt 包中的函数则打印 value。&lt;/p&gt;

&lt;p&gt;总之，这两个函数是个特殊的函数，一般也用不上，了解下就行了。&lt;/p&gt;

&lt;h3 id=&#34;error&#34;&gt;error&lt;/h3&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gfw.go101.org/article/basic-types-and-value-literals.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;基本类型和它们的字面量表示&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/14680255/difference-between-fmt-println-and-println-in-go&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Difference between fmt.Println() and println() in Go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/astaxie/gopkg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;example for the go pkg&amp;rsquo;s function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/335186436&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Golang 中 fmt.Println 和直接 println 有什么区别&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go errors 包讲解</title>
      <link>https://edte.github.io/2020/2020-06-02-go-errors-%E5%8C%85%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-02-go-errors-%E5%8C%85%E8%AE%B2%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;go 包实现了处理 error 的一些功能。&lt;/p&gt;

&lt;p&gt;这是源码注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Package errors implements functions to manipulate errors.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;errors 包的源码放在 &lt;code&gt;$GOROOT/src/errors&lt;/code&gt; 中&lt;/p&gt;

&lt;p&gt;查看安装目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go env GOROOT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便阅读源码和调试，建议将源码复制后作为新项目打开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -r errors ~/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;

&lt;p&gt;errors 包有两个文件，errors.go 和 wrap.go 以及三个测试文件。&lt;/p&gt;

&lt;h2 id=&#34;errors-go&#34;&gt;errors.go&lt;/h2&gt;

&lt;p&gt;errors.go 中有一个 errorString 结构体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// errorString is a trivial implementation of error.
type errorString struct {
	s string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读注释我们明白，这个结构体是 error 的简单实现。我们可以自定义错误的类型，而这个结构体就是源码中对错误的一个简单实现。&lt;/p&gt;

&lt;p&gt;然后有这个结构体的 constructor，即 New 函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// New returns an error that formats as the given text.
// Each call to New returns a distinct error value even if the text is identical.
func New(text string) error {
	return &amp;amp;errorString{text}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现返回一个 error, 继续读源码，我们知道这是一个接口，在 builtin 包 builtin.go 文件中， builtin 包用来给有预定义标识符生成文档，也就是说这个包里都是一些预定义标识符，这些标识符的具体实现没有在这个包里，写这个包只是为了使用 goget 生成文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个接口是用来表示错误状态的，只要实现了 Error() 方法，那么就实现了这个接口。也就是说，我们可以自定义一个类型，然后实现 Error() 方法，这个类型就是我们自定义的错误类型。当这个接口为 nil 时，没有错误，所以我们一般来判断这个接口是否为空，来判断是否出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	if err := A(); err != nil {
	//
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余下的 Error() 函数就是 errorString 的方法，所以 errorString 实现了 error 接口，所以 errorStirng 可以转换为 error 类型，所以才返回 errorString 类型，而函数签名处是 error 类型。&lt;/p&gt;

&lt;p&gt;我们可以看 fmt 包 errors.go 文件中，就自定义了一个错误类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type wrapError struct {
	msg string
	err error
}

func (e *wrapError) Error() string {
	return e.msg
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码我们可以知道，errors.go 文件主要就是 围绕 error 接口展开的，接下来我们来看测试文件中具体的例子。&lt;/p&gt;

&lt;h2 id=&#34;example-test-go&#34;&gt;example_test.go&lt;/h2&gt;

&lt;p&gt;自定义一个类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// MyError is an error implementation that includes a time and message.
type MyError struct {
	When time.Time
	What string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现 error 接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (e MyError) Error() string {
	return fmt.Sprintf(&amp;quot;%v: %v&amp;quot;, e.When, e.What)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了 opps 函数封装了一下，我们可以模仿 errors.go 中把它改为 constructor，即 New 函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func New(s string) error {
	return &amp;amp;MyError{time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), s}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	if err := New(&amp;quot;haha&amp;quot;); err != nil {
		fmt.Println(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可得 &lt;code&gt;1989-03-15 22:30:00 +0000 UTC: haha&lt;/code&gt;，这个即我们定义的 error 类型的具体实现。&lt;/p&gt;

&lt;h2 id=&#34;errors-test-go&#34;&gt;errors_test.go&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ExampleNew()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有测试 New 函数的，即新生成一个 error 类型，这个类型的格式只有一个 string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ExampleNew() {
	err := errors.New(&amp;quot;emit macho dwarf: elf header corrupted&amp;quot;)
	if err != nil {
		fmt.Print(err)
	}
	// Output: emit macho dwarf: elf header corrupted
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TestErrorMethod()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有测试方法的，我们生成一个 error 类型后，这个类型实现了 error() 方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestErrorMethod(t *testing.T) {
	err := errors.New(&amp;quot;abc&amp;quot;)
	if err.Error() != &amp;quot;abc&amp;quot; {
		t.Errorf(`New(&amp;quot;abc&amp;quot;).Error() = %q, want %q`, err.Error(), &amp;quot;abc&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里容易搞混 err 和 err.Error(), 不知道它们有什么区别，这里我们来看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	err := errors.New(&amp;quot;sdf&amp;quot;)

	fmt.Println(reflect.TypeOf(err)) //*errors.errorString
	fmt.Println(reflect.ValueOf(err)) //sdf

	e := err.Error()
	fmt.Println(reflect.TypeOf(e))  //string
	fmt.Println(reflect.ValueOf(e)) //sdf
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New 函数返回一个 error 接口的实例，这个接口是 errorString 的实现，所以 err 是个接口，它的动态类型是 *errors.errorString, 值是实例传入的 errorString 的值 sdf.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func New(text string) error {
	return &amp;amp;errorString{text}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;err 是个接口，error() 就是 err 接口方法集中的 error() 方法，所以这里 err.Error() 就是调用 Error() 方法，把返回值赋给 e，返回值是 string, 所以 e 的类型是 string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 e 是实例 err 创建出来的，err 接口这里是 errorString 实现的，所以这里就是传入的 sdf，sdf 赋给 errorString 的 是，Error() 再获取 s, 所以 e 的 值就是 sdf&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ExampleNew_errorf()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有 格式化新建 error 的，即 ExampleNew_errorf 函数，这个函数用了 fmt 包中的 Errorf 函数，这个函数用来用来新建格式化 error，用到了自建的一种格式，即 wrapError struct, 也就是我们在 error 自建类型中讲到的，不过这里不具体展开其实现原理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The fmt package&#39;s Errorf function lets us use the package&#39;s formatting
// features to create descriptive error messages.
func ExampleNew_errorf() {
	const name, id = &amp;quot;bimmler&amp;quot;, 17
	err := fmt.Errorf(&amp;quot;user %q (id %d) not found&amp;quot;, name, id)
	if err != nil {
		fmt.Print(err)
	}
	// Output: user &amp;quot;bimmler&amp;quot; (id 17) not found
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TestNewEqual()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关于 New 函数特点的，我们再来看一下 New 函数的源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func New(text string) error {
	return &amp;amp;errorString{text}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它返回时，建立了一个临时变量 errorString  类型，而我们在区分 err 和 error 时知道，New 函数返回时，返回了一个指针，如果忘记了，可以运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(reflect.TypeOf(errors.New(&amp;quot;sdf&amp;quot;)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以如果直接比较两个 errors.New(), 哪怕输入的字符串相同，它们也是不相同的两个变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(errors.New(&amp;quot;f&amp;quot;) == errors.New(&amp;quot;f&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这里是 &lt;code&gt;flase&lt;/code&gt;, 我们就不能这样判断错误是否相同，我们可以先赋值给一个变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	err := errors.New(&amp;quot;df&amp;quot;)
	fmt.Println(err == err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 err 是一个变量，所以是 &lt;code&gt;true&lt;/code&gt;, 或者我们可以通过 Error() 方法获取它们的值，再比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(errors.New(&amp;quot;f&amp;quot;).Error() == errors.New(&amp;quot;f&amp;quot;).Error())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;故是 &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;wrap-go&#34;&gt;wrap.go&lt;/h2&gt;

&lt;h2 id=&#34;wrap-test-go&#34;&gt;wrap_test.go&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>go 标识符命名指南</title>
      <link>https://edte.github.io/2020/2020-06-01-go-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-01-go-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E6%8C%87%E5%8D%97/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;对标识符的命名向来是程序员们苦恼的事，这篇文章将参考标准库和一些流行轮子的命名规范来总结一下标识符的命名。&lt;/p&gt;

&lt;h2 id=&#34;基本准则&#34;&gt;基本准则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标识符命名由 Unicode 字母或下划线 &lt;code&gt;_&lt;/code&gt; 开头，后面跟一定数量的 Unicode 字母或 Unicode 数字或 下划线 &lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标识符命名不能由数字开头&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他命名可能合法，如使用中文字符为标识符，这是合法的，但并不建议这么用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大写和小写是不同的标识符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大写字母开头的标识符是 public 的，而小写字母开头的标识符是 private 的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关键字不能作为标识符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以使用预定义字符名，但是一般不建议使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空白标识符 &lt;code&gt;_&lt;/code&gt;  是一个特殊的标识符，仅用于占位&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// 合法的标识符
_a
code_0
Abc
abc

//两个不同的标识符 
mi 
mI

// public 和 private 标识符
person // private 标识符，只能在此包引用
Person //public 标识符，其他包可以引用

// 不合法的标识符, Unicode 数字开头
22
2SDf

// 不合法的标识符，含不合要求的字符
(SDf
a.b
#sdfo

// 关键字不能作为标识符
int
type

//合法的，但是不建议使用的
啊啊

// new 是预定义字符，但是可以作为标识符名
func new() {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;项目名&#34;&gt;项目名&lt;/h2&gt;

&lt;h3 id=&#34;原则&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;全小写，可以加上数字表示版本&lt;/li&gt;
&lt;li&gt;单词间使用中划线&lt;code&gt;-&lt;/code&gt;间隔，首尾不要使用中划线&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 常用框架，全小写
gorm
gin
grpc
// 单词间使用中划线（-）间隔
go-spew
go-mssqldb
go-testdb
universal-translator
// 可以使用数字表示特殊意义
go-sqlite3
reflect2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;目录名&#34;&gt;目录名&lt;/h2&gt;

&lt;h3 id=&#34;原则-1&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;与包名相同&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量一个单词，或一个单词加缩写&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全小写，不使用下划线 &lt;code&gt;_&lt;/code&gt; 或中划线 &lt;code&gt;-&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量不要与标准库重名&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-1&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 标准库
archive
bufio
cmd

// gin 框架目录
binding
examples
internal
render

// 标准库有 database，就不要重名了
db
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文件名&#34;&gt;文件名&lt;/h2&gt;

&lt;h3 id=&#34;原则-2&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;全小写字母，可以加数字表示特殊意义&lt;/li&gt;
&lt;li&gt;用下划线&lt;code&gt;_&lt;/code&gt; 隔离单词，但是尽量少用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-2&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 标准库 archive/tar 包
//全小写
common.go
strconv.go

// 下划线分割单词
example_test.go  // _.test.go 是测试文件
stat_unix.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;包名&#34;&gt;包名&lt;/h2&gt;

&lt;h3 id=&#34;原则-3&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;与目录名相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tips:&lt;/p&gt;

&lt;p&gt;为什么包名要与目录名相同：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;导包时导入的是目录名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个目录下都是一个包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体可以看&lt;a href=&#34;a&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;全小写&lt;/li&gt;
&lt;li&gt;不使用下划线或中划线风格单词&lt;/li&gt;
&lt;li&gt;尽量不要与标准库重名&lt;/li&gt;
&lt;li&gt;包内的类型和函数不用加说明在哪个包&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-3&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 标准库
log
time
http
rpc
// 流行轮子
gin
gorm

// 不要与标准库或轮子重名
mysql -&amp;gt; mys 
redis -&amp;gt; red
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常量名&#34;&gt;常量名&lt;/h2&gt;

&lt;h3 id=&#34;原则-4&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;不使用下划线&lt;/li&gt;
&lt;li&gt;首字母大小为 public，小写为 private&lt;/li&gt;
&lt;li&gt;将常量按类型分类&lt;/li&gt;
&lt;li&gt;公有常量放在私有常量前&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-4&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 标准库 builtin 包，单个单词，小写
const (
	true  = 0 == 0 
	false = 0 != 0 
)

// 标准库 io 包，多个单词使用驼峰分割
const (
	SeekStart   = 0 
	SeekCurrent = 1 
	SeekEnd     = 2 
)

// go-sql-driver/mysql 库 const.go 文件
const (
	iOK           byte = 0x00
	iAuthMoreData byte = 0x01
	iLocalInFile  byte = 0xfb
	iEOF          byte = 0xfe
	iERR          byte = 0xff
)
const (
	defaultAuthPlugin       = &amp;quot;mysql_native_password&amp;quot;
	defaultMaxAllowedPacket = 4 &amp;lt;&amp;lt; 20 // 4 MiB
	minProtocolVersion      = 10
	maxPacketSize           = 1&amp;lt;&amp;lt;24 - 1
	timeFormat              = &amp;quot;2006-01-02 15:04:05.999999&amp;quot;
)

//
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;接口名&#34;&gt;接口名&lt;/h2&gt;

&lt;h3 id=&#34;原则-5&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;不使用下划线&lt;/li&gt;
&lt;li&gt;首字母大小为 public，小写为 private&lt;/li&gt;
&lt;li&gt;单个函数的接口以 &lt;code&gt;er&lt;/code&gt; 结尾&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-5&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 标准库 io 包 io.go 文件
//  单函数接口以 er 结尾
type Reader interface {
	Read(p []byte) (n int, err error)
}
// 驼峰命名
type ReadWriter interface {
	Reader
	Writer
}

// redigo 包 redis.go 文件
type Scanner interface {
    RedisScan(src interface{}) error
}

type Conn interface {

	Close() error

	Err() error

	Do(commandName string, args ...interface{}) (reply interface{}, err error)

	Send(commandName string, args ...interface{}) error

	Flush() error

	Receive() (reply interface{}, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结构体名&#34;&gt;结构体名&lt;/h2&gt;

&lt;h3 id=&#34;原则-6&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;不使用下划线&lt;/li&gt;
&lt;li&gt;首字母大小为 public，小写为 private&lt;/li&gt;
&lt;li&gt;结构体成员名和结构体名原则相同&lt;/li&gt;
&lt;li&gt;为名词&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-6&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// sync 包 waitGroup.go 文件
// 驼峰命名
type WaitGroup struct {
	// 成员也是驼峰命名
	noCopy noCopy
	state1 [3]uint32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参数名&#34;&gt;参数名&lt;/h2&gt;

&lt;h3 id=&#34;原则-7&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;首字母小写&lt;/li&gt;
&lt;li&gt;尽可能短，尽量为参数类型的首字母，或一个单词&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-7&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// fmt 包
//首小写，短
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
}

// 驼峰
func (p *pp) fmtBytes(v []byte, verb rune, typeString string) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;返回值名&#34;&gt;返回值名&lt;/h2&gt;

&lt;h3 id=&#34;原则-8&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;首字母小写&lt;/li&gt;
&lt;li&gt;尽可能短，尽量为参数类型的首字母，或一个单词&lt;/li&gt;
&lt;li&gt;尽量不使用命名参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-8&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// bufio 包
// 首字母小写，短
func (b *Reader) Discard(n int) (discarded int, err error) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;receiver-名&#34;&gt;Receiver 名&lt;/h2&gt;

&lt;h3 id=&#34;原则-9&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;尽量几个字母或一个字母&lt;/li&gt;
&lt;li&gt;小写&lt;/li&gt;
&lt;li&gt;尽量为类型的首字母&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-9&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// bufio 包
func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数名&#34;&gt;函数名&lt;/h2&gt;

&lt;h3 id=&#34;原则-10&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;不使用下划线&lt;/li&gt;
&lt;li&gt;首字母大小为 public，小写为 private&lt;/li&gt;
&lt;li&gt;表功能的尽量使用动词&lt;/li&gt;
&lt;li&gt;表判断的尽量使用 Is/Have 等前缀&lt;/li&gt;
&lt;li&gt;使用 construtor，在 type前加 new&lt;/li&gt;
&lt;li&gt;getter 直接为变量名&lt;/li&gt;
&lt;li&gt;setter 在变量前加 set&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-10&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//log 包
// 驼峰，动词，public
func Fatalln(v ...interface{}) {}
// filepath 包
// Is 前缀
func IsAbs(path string) bool {}

//construtor
type person struct {
}

func newPerson() *person {
	return &amp;amp;person{}
}

// getter
type person struct {
	name string
}

func (p *person) Name() string {
	return p.name
}

//setter
type person struct {
	name string
}

func (p *person) SetName(name string) {
	p.name = name
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;变量名&#34;&gt;变量名&lt;/h2&gt;

&lt;h3 id=&#34;原则-11&#34;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用驼峰命名法（camelcase）&lt;/li&gt;
&lt;li&gt;不使用下划线&lt;/li&gt;
&lt;li&gt;首字母大小为 public，小写为 private&lt;/li&gt;
&lt;li&gt;遇到专有名词保持原样&lt;/li&gt;
&lt;li&gt;变量长度与作用域正相关&lt;/li&gt;
&lt;li&gt;循环变量使用单个字母&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实例-11&#34;&gt;实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 专有名词
URLArray 或 urlArray 非 UrlArray

// gin 包
// 全句变量，长
var (
	default404Body   = []byte(&amp;quot;404 page not found&amp;quot;)
	default405Body   = []byte(&amp;quot;405 method not allowed&amp;quot;)
	defaultAppEngine bool
)

// 局部变量，短
c := engine.pool.Get().(*Context)

// 驼峰
rPath := req.URL.Path

//循环变量
for i := range &amp;quot;hah&amp;quot;{
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>go 注释讲解</title>
      <link>https://edte.github.io/2020/2020-06-01-go-%E6%B3%A8%E9%87%8A%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-01-go-%E6%B3%A8%E9%87%8A%E8%AE%B2%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;注释的重要性不言而寓，而怎么编写注释也是需要我们学习的，最好的学习教程就是源码，这篇文章将大量参考 go 库文件源码。&lt;/p&gt;

&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;

&lt;p&gt;go 的注释有行注释 &lt;code&gt;//&lt;/code&gt; 和块注释 &lt;code&gt;/* */&lt;/code&gt; 之分。在实际的使用中，行注释使用得比较多，块注释主要用于格式化大段代码或包的注释中使用。&lt;/p&gt;

&lt;p&gt;在 goland 中行注释的快捷键为 &lt;code&gt;Ctrl+/&lt;/code&gt;, 块注释的快捷键为 &lt;code&gt;Ctrl+Shift+/&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;

&lt;h3 id=&#34;文件注释&#34;&gt;文件注释&lt;/h3&gt;

&lt;p&gt;在每个文件中前都加上一段注释，这段注释用来描述 作者，时间，以及版权。&lt;/p&gt;

&lt;p&gt;我们可以随便打开一个包查看，如 builtin.go 包中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就有时间 2011,作者 go，和版权，我们可以随便打开其他文件，可以发现只有时间在变，而其他都没有变化。&lt;/p&gt;

&lt;p&gt;在 goland 中可以在 &lt;code&gt;Settings/Editor/File and Code Templates/Files/Go File&lt;/code&gt; 中寻改文件注释模板，这样每次新建文件都会自动生成注释。&lt;/p&gt;

&lt;p&gt;这是我的模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//@program: ${PROJECT_NAME}
//@author: edte
//@create: ${YEAR}-${MONTH}-${DAY} ${HOUR}:${MINUTE}
package ${GO_PACKAGE_NAME}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;包注释&#34;&gt;包注释&lt;/h3&gt;

&lt;p&gt;包注释用来描述介绍这个包，以及提供包的一些信息。&lt;/p&gt;

&lt;p&gt;在 go 中，一个 目录中只有一个包（不包扩子目录），所以一个包中可以有多个文件，一般在其中一个文件写上包注释即可。&lt;/p&gt;

&lt;p&gt;同样的，我们来看 builtin 这个包 中的 builtin.go 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
	Package builtin provides documentation for Go&#39;s predeclared identifiers.
	The items documented here are not actually in package builtin
	but their descriptions here allow godoc to present documentation
	for the language&#39;s special identifiers.
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 builtin 包的作用是给预定义标识符提供文档。&lt;/p&gt;

&lt;p&gt;我们同样来看 errors 包中的 errors.go 文件，可以看到包注释很长&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Package errors implements functions to manipulate errors.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里讲了包 errors 实现了一些处理错误的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The New function creates errors whose only content is a text message.
//
// The Unwrap, Is and As functions work on errors that may wrap other errors.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面还有一大堆，讲了 errors 包相关的文件，原理，应用等信息。&lt;/p&gt;

&lt;p&gt;如果我们继续查看源码，会发现包注释都是以 &lt;code&gt;package + 一个动词&lt;/code&gt; 开头的，一般这个短句就说明了这个包的功能，然后再视具体的包说明包的其他信息。&lt;/p&gt;

&lt;h3 id=&#34;函数注释&#34;&gt;函数注释&lt;/h3&gt;

&lt;p&gt;函数注释用来描述函数的功能，以及其他相关的信息。&lt;/p&gt;

&lt;p&gt;我们同样来看 errros 包中的 errors.go 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// New returns an error that formats as the given text.
// Each call to New returns a distinct error value even if the text is identical.
func New(text string) error {
	return &amp;amp;errorString{text}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用一句话说明了 New 功能的作用，即返回一个自定义的错误。&lt;/p&gt;

&lt;p&gt;然后又用一句话说了这个函数相关的特点，即使文本相同，每次对New的调用也会返回一个不同的错误值。&lt;/p&gt;

&lt;p&gt;如果同样查看其他源码中的函数，我们发现一般几乎都是 &lt;code&gt;函数名 + 一个动词&lt;/code&gt; 的句子开头。这个句子同样说明了这个函数的作用，即函数干了些什么。&lt;/p&gt;

&lt;p&gt;而其他需要讲解的信息则以复杂度为基础，如果感觉某个点不容易理解，那么最好都要写注释，如函数签名，函数原理，函数使用过程中需要注意的点等。&lt;/p&gt;

&lt;h3 id=&#34;数据类型注释&#34;&gt;数据类型注释&lt;/h3&gt;

&lt;p&gt;数据类型注释说明 这个数据类型用来干什么。&lt;/p&gt;

&lt;p&gt;如 errors.go 中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// errorString is a trivial implementation of error.
type errorString struct {
	s string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就说明了  errorString 的作用，即 error 的具体实现。&lt;/p&gt;

&lt;p&gt;如 built.go 中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bool is the set of boolean values, true and false.
type bool bool

// true and false are the two untyped boolean values.
const (
	true  = 0 == 0 // Untyped bool.
	false = 0 != 0 // Untyped bool.
)

// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几乎都是以 &lt;code&gt;类型名 + is&lt;/code&gt;开头的句子，这个句子说明了这个类型的作用。&lt;/p&gt;

&lt;h3 id=&#34;todo&#34;&gt;TODO&lt;/h3&gt;

&lt;p&gt;TODO 即 to do, 是一个特殊的注释，表明在此处有功能等待编写，&lt;/p&gt;

&lt;h3 id=&#34;fixme&#34;&gt;FIXME&lt;/h3&gt;

&lt;p&gt;FIXME 即 fix me, 也是一个特殊的注释，表明此处的功能需要修正，甚至不能运行&lt;/p&gt;

&lt;h3 id=&#34;xxx&#34;&gt;XXX&lt;/h3&gt;

&lt;p&gt;XXX 也是一个特殊的注释，表明此处的功能实现方法有点问题，需要更改&lt;/p&gt;

&lt;h2 id=&#34;godoc&#34;&gt;godoc&lt;/h2&gt;

&lt;p&gt;godoc 是一个实用的工具，可以根据特定的注释格式生成文档。也可以用来查看文档，同样的 go doc 命令也是相似的作用，具体的可以查看这篇文章。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://learnku.com/docs/effective-go/2020/code-annotation/6238&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt; 代码注释&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/comments/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;注释&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>充电宝选购指南</title>
      <link>https://edte.github.io/2020/2020-06-01-%E5%85%85%E7%94%B5%E5%AE%9D%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-06-01-%E5%85%85%E7%94%B5%E5%AE%9D%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</guid>
      <description>

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;移动电源(power bank) 是一种随身携带，能为电子产品充电的便携式充电器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般我们所说的充电宝就是功率比较小的移动电源，只能给小型电子设备充电，如手机，mp3 等。同时也有功率比较大的移动电源，可以给笔记本等额定功率比较大的电子设备，这里我们只介绍充电宝相关。&lt;/p&gt;

&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;

&lt;p&gt;充电包由外壳，主板，电芯构成。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;外壳提供美观，固定内部电路板，阻燃耐高温的作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同人有着不同的审美观，这里就不具体展开。外壳有塑料和金属的类型，金属更耐燃，但是价格也更贵，塑料则需要选择特定的类型，一般建议购买 PC+ABS 的。由于多数人购买时都不会考虑这一点，所以我们这里并不展开。&lt;/p&gt;

&lt;p&gt;塑料外壳
&lt;img src=&#34;http://article.fd.zol-img.com.cn/t_s640x2000/g4/M09/06/0F/Cg-4WlR8Oz6IfzbCAAO1h94wUUcAARisgGdRkIAA7Wf590.jpg&#34; alt=&#34;a&#34; /&gt;
金属外壳
&lt;img src=&#34;http://article.fd.zol-img.com.cn/t_s640x2000/g4/M08/06/0F/Cg-4WVR8PcKIF_YHAAMDPgOQYHMAARivQKbwLgAAwNW680.jpg&#34; alt=&#34;b&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主板&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主板一般都是 pcb 板，这个电路板集成了许多功能，我们挑选时主要考虑这些功能，如升压，稳压，温度保护，自动断电等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://article.fd.zol-img.com.cn/t_s640x2000/g4/M09/06/0F/Cg-4WlR8Oz-IclJ5AAM68TvdIhcAARisgG4CeIAAzsJ177.jpg&#34; alt=&#34;c&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;电芯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;电芯是电池中比较重要的部分，它负责给电池提供动力，同时这也是导致充电宝爆炸的根源，这也是我们选购时主要考虑的东西。&lt;/p&gt;

&lt;p&gt;电芯的类型&lt;/p&gt;

&lt;p&gt;市场上充电宝的电芯一般有两种，18650 电芯和聚合物电芯。&lt;/p&gt;

&lt;p&gt;18650 电芯有点像 7 号电池，这种电芯价格便宜，容量大，但是同时安全性也要低一些。市场上如果遇到这种类型的充电宝，如果不是靠谱的大品牌，那最好绕道走。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i0.hdslb.com/bfs/article/86688a34f61b10b8b31f64e5031ccd8f0d75494b.jpg@1320w_710h.webp&#34; alt=&#34;d&#34; /&gt;&lt;/p&gt;

&lt;p&gt;聚合物电芯即手机电池使用的那种，没有形状，价格稍贵，但同时安全性也要高许多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i0.hdslb.com/bfs/article/03b065462c07ffa62b30d90e331c38fb67e4facc.jpg@1320w_790h.webp&#34; alt=&#34;e&#34; /&gt;&lt;/p&gt;

&lt;p&gt;电芯的容量&lt;/p&gt;

&lt;p&gt;我们一般说多少毫安的充电宝，说的都是电芯的容量。&lt;/p&gt;

&lt;p&gt;电芯的品牌&lt;/p&gt;

&lt;p&gt;日本索尼，日本三洋，日本松下，日本东芝&lt;/p&gt;

&lt;p&gt;韩国三星，韩国 LG&lt;/p&gt;

&lt;p&gt;国产比克，国产长江，国产力神(ATL)&lt;/p&gt;

&lt;p&gt;国产的电芯和进口的还是有一定差距的，如果要购买优秀一点的电芯，应该优先考虑进口电芯。一般进口的都会在产品页标出电芯品牌，没有标出的话建议问客服或者找拆机视频。&lt;/p&gt;

&lt;p&gt;大品牌的电芯一般都不会有太大的问题，反正不要购买没有听过的杂牌电芯，否则爆炸警告！&lt;/p&gt;

&lt;p&gt;不同品牌电芯还是有着差距的，侧重电芯类型也不同，建议根据具体需求展开了解。&lt;/p&gt;

&lt;h2 id=&#34;容量&#34;&gt;容量&lt;/h2&gt;

&lt;p&gt;充电宝的容量是我们选购时首先考虑的几个要素之一，定了容量，几乎就定了充电宝的大小，而对大小的要求则每个人都不一样。&lt;/p&gt;

&lt;p&gt;我们一般说多少毫安的充电宝，说的都是电芯的容量。而我们如果学过物理的话，就知道在传输过程中，损耗是不可避免的。在使用过程中，电流进过主板会消耗一部分，这个就是板端转化率，然后在线材传输过程中又消耗一部分，最后在进入手机电池模块芯片又消耗一部分，所以总的损耗是比较高的。&lt;/p&gt;

&lt;p&gt;现在我们在充电宝参数中一般还能看到额定容量，这是国家规定要写的。我们知道手机有不同的协议，充电时的电流和电压都不是固定的，所以额定容量也是随着改变的。一般充电宝参数上的额定容量都写着对应的电流电压，实际使用什么协议是不清楚的，不过我们也无需理解具体的数值。知道容量与额定容量这些概念即可。&lt;/p&gt;

&lt;h2 id=&#34;接口&#34;&gt;接口&lt;/h2&gt;

&lt;p&gt;输出接口：至少一个 USB-A，用来给手机充电，另一头连接手机&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.techritual.com/wp-content/uploads/2018/01/USB31ACXM.C_bljcbm.jpg&#34; alt=&#34;f&#34; /&gt;&lt;/p&gt;

&lt;p&gt;输入接口：给充电宝充电的接口，一般有三种&lt;/p&gt;

&lt;p&gt;Micro USB, 老安卓手机使用的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.techritual.com/wp-content/uploads/2018/01/233_fgedc8.jpg&#34; alt=&#34;a&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Type-C(USB-C), 现在多数安卓手机使用的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.techritual.com/wp-content/uploads/2018/01/534359-what-is-usb-c-an-explainer_nmkltr.png&#34; alt=&#34;e&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lightning，苹果平台使用的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.techritual.com/wp-content/uploads/2018/01/apple-lightning-to-usb-cable_zq6u30.jpg&#34; alt=&#34;a&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单口输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只用一个输出口时支持的电流电压&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;双口输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时使用两个输出口（同时给两个手机充电）的电流电压&lt;/p&gt;

&lt;h2 id=&#34;功率&#34;&gt;功率&lt;/h2&gt;

&lt;p&gt;充电宝一般都有一个支持的最大功率，我们知道功率=电流 x 电压，功率越大，充电速度越快。&lt;/p&gt;

&lt;p&gt;一般默认都是 5V/2A 的，也就是 10 W，而其他功率要看充电宝支持什么协议。&lt;/p&gt;

&lt;h2 id=&#34;快充&#34;&gt;快充&lt;/h2&gt;

&lt;p&gt;充电速度是我们经常关心的一个问题，要提高充电速度，就要靠快充协议。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快充反向&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单向快充：仅充电宝给手机充电支持快充&lt;/p&gt;

&lt;p&gt;双向快充：充电宝给手机充电和手机给充电宝充电都支持快充&lt;/p&gt;

&lt;p&gt;注意，支持快充协议并不是充电都是快充，还要考虑充电宝和手机支持的快充协议，和相应的数据线，充电头，所以不要问为什么充电速度那么慢了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快充协议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;历史&lt;/p&gt;

&lt;p&gt;没有使用快充的手机一般都遵循着低倍率充电标准 “5V 0.2C”，如果是 1000mAh 容量的电池，1C 就是指充电电流为 1A；2000mAh 容量的电池，1C 就是指充电电流为 2A，现在一般电池都大于 2000 mAh,  所以一般都是 5v/2A 10W 的。&lt;/p&gt;

&lt;p&gt;快充同时要手机内置的电源管理芯片、充电线、充电器三部分共同协调，而早期使用的 Micro USB 无法承受过高的电流，所以早期都是提高电压来提高功率，如早期的高通的 qc 协议，之后 oppo 对这三部分都同时定制，通过提高电流来提高功率，这在当时火了一把，而之后 Type-C 车出现使提高电流的方式变得可能，pd 充电协议就是通过提高电流的一个协议，现在多数使用 Type-C 的手机都支持 pd 协议。除此之外各个厂商也有着自己的协议，这导致许多充电线和充电器只能在特定手机使用，出现了一些兼容问题。&lt;/p&gt;

&lt;p&gt;具体&lt;/p&gt;

&lt;p&gt;qc 协议：高通公司弄的一个协议，通过提高电压来提高功率。市面上大部分高通芯片的手机都支持这个协议。&lt;/p&gt;

&lt;p&gt;pd 协议：通过提高电流来提高功率，大部分使用 Type-C 的手机都支持。&lt;/p&gt;

&lt;p&gt;ep协议：联发科&lt;/p&gt;

&lt;p&gt;VOOC 协议：opp&lt;/p&gt;

&lt;p&gt;DASH 协议：一加&lt;/p&gt;

&lt;p&gt;SCP 协议： 华为&lt;/p&gt;

&lt;p&gt;具体的协议还有许多，这里只是列出常用的几个，一般的充电宝都支持 qc 和 pd ，ep 协议，这些是主流的协议，其他具体的协议要看具体的手机，也要买对应的数据线和充电宝，如购买了一加，那么需要支持一加 DASH 协议的数据线，充电宝，一般的可能就不符合。&lt;/p&gt;

&lt;p&gt;想要详细了解充电协议可以进一步阅读  &lt;a href=&#34;https://zhuanlan.zhihu.com/p/31321267&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;手机快充完全指南&lt;/a&gt;  &lt;a href=&#34;https://www.ifanr.com/1187376&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;关于手机充电&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;品牌&#34;&gt;品牌&lt;/h2&gt;

&lt;p&gt;充电宝品牌就是最后的成品了，选择这个的原则就是不要选杂牌，不要图便宜选那些没有听过的牌子，更不要选 diy 的，这里面鱼龙混杂，小白就不要往里面冲了。这里推荐一些比较好的牌子&lt;/p&gt;

&lt;p&gt;索尼，小米，anker，紫米 等等，暂时不推荐 罗马仕，最近网上爆炸新闻有点多&lt;/p&gt;

&lt;h2 id=&#34;实践&#34;&gt;实践&lt;/h2&gt;

&lt;p&gt;科普了一些知识后，我们来实际选择一款来学习下怎么选购。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;明确自己的手机支持的协议和功率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里拿我现有的手机 pixel2 为例，通过查询得知 pixel2 支持 pd 协议，18 w(9V/2A), 如果查询不到的话，建议查看原装充电头，上面一般都写得有，如果找不到的话，网上一般也有拆机，可以自行查找。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定预算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我准备了 200 的预算&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定容量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我比较喜欢容量大的，比较有安全感，所以我至少要 2w 的容量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寻找产品，分析&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里不建议直接到购物网站去搜索，因为比较火热的难以判断，有的甚至是广告，建议去垂直社区看别人的推荐，如酷安，贴吧的问答，或者看别人的测评，如少数派，知乎的一些问答。&lt;/p&gt;

&lt;p&gt;别人推荐时，一般会说容量和价格，选择那些分析有理的，推荐比较多的，这里我拿 罗马仕 2w 的为例，这个推荐的人比较多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bbs.chongdiantou.com/data/attachment/forum/201811/13/150121gd4i4y6v4jy3zjaz.jpg&#34; alt=&#34;a&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先价格在 100 左右（这里不讲各种优惠，打折等），符合。&lt;/p&gt;

&lt;p&gt;然后容量 2w，符合。&lt;/p&gt;

&lt;p&gt;然后看一下电芯，商品详情页上没写，可以问客服，如果客服不说的话，那一般就是国产垃圾电芯了，可以去看拆机讲解。如&lt;a href=&#34;http://www.chongdiantou.com/wp/archives/17535.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这篇&lt;/a&gt; 讲解，可以看到电芯是罗马仕自己搞的，如果在意的话就不用看这个款了，不过这里假设可以接受&lt;/p&gt;

&lt;p&gt;然后协议，看了一下，双向快充都支持 pc 协议，9v 2a 18 w的。符合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bbs.chongdiantou.com/data/attachment/forum/201811/13/150125g4p8gtz43r5toit8.jpg&#34; alt=&#34;a&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后看一下接口，三种输入接口都有，一个普通输出接口，一个快充输出接口，够用，ok&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bbs.chongdiantou.com/data/attachment/forum/201811/13/150122bmge7yym3ye77279.jpg&#34; alt=&#34;a&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后看一下外观，白色，塑料，重量，我不在意，ok。&lt;/p&gt;

&lt;p&gt;然后看一下功能，温度保护，过压保护，过功率保护等一般的功能都有，ok。&lt;/p&gt;

&lt;p&gt;然后可以看一下关于这款商品具体的评价了，可以到购物网站去看具体的用户评价，或者在搜索引擎搜索一些用户的评价。看有哪些频繁出现的问题，自己是不是能够接受，比如这里我就经常看见有用户充了一段时间就充不进去电了，不过这个可能是品控的问题，再加上有一年的保修，一般来说还是可以接受，还有些出现经常跳水，二手，没有发票（哦，这是某网站的问题），等等，这里假设我已经满意了&lt;/p&gt;

&lt;p&gt;最后就是购买了，如果不在意钱的话直接买吧，如果想节约一下可以等特殊的打折 如 6.18 什么的，或者找优惠卷，这样一款可以接受的充电宝就抱回家啦。&lt;/p&gt;

&lt;p&gt;以上都是穷人版购物指南，土豪请在贵的里调个好看的就行了（笑&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go 常用命令介绍</title>
      <link>https://edte.github.io/2020/2020-05-09-go-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-05-09-go-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/</guid>
      <description>

&lt;h2 id=&#34;命令介绍&#34;&gt;命令介绍&lt;/h2&gt;

&lt;p&gt;go 语言自带了一些命令行命令，熟悉这些命令对开发有一定的好处。&lt;/p&gt;

&lt;p&gt;可以使用 &lt;code&gt;go&lt;/code&gt; 或 &lt;code&gt;go help&lt;/code&gt; 查看&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202005/1823594-20200529114338606-1546045202.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;往下看，有&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1823594/202005/1823594-20200529114624595-1820369286.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;故我们可以使用 &lt;code&gt;go help cmd_name&lt;/code&gt; 命令查看具体的命令，如 &lt;code&gt;go help build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也可以直接查看 &lt;a href=&#34;https://golang.org/cmd/go/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;, 下面我们来讲解一些常用的命令，主要参考官方文档和使用实际的例子来说明&lt;/p&gt;

&lt;h2 id=&#34;go-build&#34;&gt;go build&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;go help build&lt;/code&gt; 查看详情或者直接在官方文档查看，为了方便，这里统一使用官方文档，而不使用截图&lt;/p&gt;

&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;go build 只会编译 main 包下的 main 文件。我们知道 go 的入口文件是 main 包，入口函数是 main 函数，故 go build 编译也只会从这里开始编译，如果在其他包，或者 main 包下没有 main 函数，要么得不到结果，要么报错。&lt;/p&gt;

&lt;p&gt;go build 编译生成的二进制文件在当前目录。&lt;/p&gt;

&lt;p&gt;go build 命令用于编译 package 和依赖包。但是仅仅用于编译，并没有 install，比如常用的 tldr 命令，这是用 go 编写的命令行提示工具，使用 go build 命令只是编译得到了结果，并没有安装到 pc 中; 同时也没有 run， 编译得到了一个二进制文件，根据平台不同得到的结果不同，在 win 下是 exe 文件，在 Linux 下则是个无后缀的二进制文件。&lt;/p&gt;

&lt;p&gt;这里我们使用一个简单的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── go.mod
├── go.sum
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go.mod 和 go.sum 文件是 mod 包管理工具产生的，不用管。在 main.go 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-、&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	fmt.Println(&amp;quot;Hello World&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们进入项目所在目录，我们这里给项目取为 gee,  目录是 $GOPATH/src/gee, 进入此目录后，使用 &lt;code&gt;go build main.go&lt;/code&gt; 命令，可以看到得到了一个 &lt;code&gt;main&lt;/code&gt; 文件，我们可以使用 &lt;code&gt;./main&lt;/code&gt; 命令执行这个二进制文件，会发现输出了 Hello World, 说明我们成功了。&lt;/p&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;查看文档，我们发现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go build [-o output] [-i] [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现有几个参数， o, i,  falgs, packages&lt;/p&gt;

&lt;p&gt;其中每个都不是必选的，packages 是包名，如果我们不加包名，那么会自动编译当前目录下的 main 函数，当然此包需要是 main 包且有 main 函数。&lt;/p&gt;

&lt;p&gt;我们知道 go 只 package 是以目录为单位的，一个 directory 下都是一个目录，故 packages 参数可以为目录下的 main 函数所在文件，也可以是目录名。如果是文件，则默认生成的二进制文件就是这个文件名，如果是目录名或不加，这默认是目录名，如果是顶级目录，则默认是项目名，下面我们来举个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── app
│   └── num.go
├── cmd
│   └── main.go
├── go.mod
├── go.sum
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个项目名 gee，有两个 main 包，根目录下的 main.go 和 cmd 目录。一个公共包，即 app。&lt;/p&gt;

&lt;p&gt;现在我们在 $GOPATH/src/gee 目录下使用 &lt;code&gt;go build&lt;/code&gt;,  根据上面的分析，我们会得到一个名为 gee 的二进制文件，这个文件就是编译 main.go 得到的。如果 main.go 中使用了其他包的函数，则同时编译这些依赖包。&lt;/p&gt;

&lt;p&gt;现在我们仍然在此目录，使用命令 &lt;code&gt;go build main.go&lt;/code&gt;, 我们会得到一个名为 main 的二进制文件，此文件也是编译 main.go 得到的。&lt;/p&gt;

&lt;p&gt;现在我们进入 cmd 目录。使用 &lt;code&gt;go build&lt;/code&gt;，我们会得到一个 名为 cmd 的二进制文件。&lt;/p&gt;

&lt;p&gt;现在我们仍在此目录，使用 &lt;code&gt;go build main.go&lt;/code&gt; 我们会得到一个 名为 main 的二进制文件。&lt;/p&gt;

&lt;p&gt;现在我们进入 app 目录，使用 &lt;code&gt;go build&lt;/code&gt;, 得不到任何文件。使用 &lt;code&gt;go build num.go&lt;/code&gt;, 也得不到任何文件。&lt;/p&gt;

&lt;p&gt;如果我们想要自定义输出的二进制文件名字，可以使用 o 参数，o 参数即 output 的缩写，容易理解，如 &lt;code&gt;go build -o hah main.go&lt;/code&gt;, 我们就会得到 hah 文件。&lt;/p&gt;

&lt;p&gt;如果我们使用的包是网络上的，如使用了 github 上的末个包，那么我们可以使用先安装依赖，或者直接使用 i 参数，先下载好依赖包，再编译。i 即 install 的缩写，容易理解，如 &lt;code&gt;go build -i main.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当我们对 main 包里的函数写测试文件时，测试文件也是 main 包下的，而 go build 命令会自动忽略测试文件，也就是 &lt;code&gt;_test.go&lt;/code&gt; 文件。&lt;/p&gt;

&lt;h2 id=&#34;go-install&#34;&gt;go install&lt;/h2&gt;

&lt;p&gt;在讲解此命令前，我们先了解一下 $GOPATH 这个环境变量，这个目录是工作目录，也就是说平时写代码时就用的这个目录，这个目录下一般有三个子目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── bin
├── pkg
├── src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别是 binary，package，source 的缩写，我们容易理解它们的意思。&lt;/p&gt;

&lt;p&gt;binary  即二进制，也就是说可执行文件，一般用于放系统使用的工具，如使用 go 命令装了一个命令行工具 tldr，那么可执行文件就放在这个目录，然后在系统上配置好环境变量，就可以直接使用这个工具。既然是可执行文件，那么编写源码的时候就需要有  main 包 和 main 函数，所以这里放置编译 main 包 main 函数后的文件。&lt;/p&gt;

&lt;p&gt;package 即包，也就是库文件，这里同样放置二进制可行性文件，但是不同于 bin 目录下放置工具，这里放置一些公共文件，也就是供其他文件使用的库文件。所以编写源码时没有 main 包 main 函数，如我们常用的 github 下许多库文件就放在这个目录。&lt;/p&gt;

&lt;p&gt;source 即源码，所以这个目录用于放置我们实际的项目文件。&lt;/p&gt;

&lt;h3 id=&#34;介绍-1&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;现在我们已经知道了这些目录的意义，那么对于 go install 目录就比较容易理解了。&lt;/p&gt;

&lt;p&gt;go install 用于编译和安装包。我们已经知道编译是怎么一回事，所以 go install 就是在 go build 的基础上，再安装包，安装的意思就是把可行性文件放置到特定目录再配置环境变量。所以 go install 就是先编译后，再把二进制文件移动到特定目录。&lt;/p&gt;

&lt;p&gt;go install 编译后的文件在特定目录。我们知道项目有 入口函数和没有如何函数两种类型，同样的，对于这两种情况移动到的目录也不同。没有入口函数的移动到 &lt;code&gt;$GOPATH/pkg&lt;/code&gt; 目录，有入口函数的移动到 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 目录。&lt;/p&gt;

&lt;h3 id=&#34;使用-1&#34;&gt;使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;go install [-i] [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看文档发现 go install 的使用和 go build 大部分都是相似的，只是不能使用 o 参数自定义输出。我们来举个实例&lt;/p&gt;

&lt;p&gt;仍然是 gee 项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── app
│   └── num.go
├── cmd
│   └── main.go
├── go.mod
├── go.sum
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 cmd 目录，使用 &lt;code&gt;go install&lt;/code&gt;, 然后查看结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $HOME/go/bin &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会发现 &lt;code&gt;cmd&lt;/code&gt; 文件&lt;/p&gt;

&lt;p&gt;在 app 目录，使用 &lt;code&gt;go install&lt;/code&gt;，然后查看结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cd $HOME/go/pkg/linux_amd64 &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会发现一个 gee/app.a 文件&lt;/p&gt;

&lt;p&gt;如果函数中使用了其他库文件，也可以加上 i 参数安装库文件。&lt;/p&gt;

&lt;h2 id=&#34;go-get&#34;&gt;go get&lt;/h2&gt;

&lt;h3 id=&#34;介绍-2&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;go get 使用代码管理工具，拉取，编译，安装远程包。代码管理工具用于下载代码，然后使用 go install 命令编译和安装包。如果使用 git 的话，就类似于使用 git clone 再 go install。&lt;/p&gt;

&lt;p&gt;不同站点使用的代码管理工具不同。常使用的 github 和 google code 都是使用的 git 作为代码管理工具。所以在拉去包前需要先安装好代码管理工具。&lt;/p&gt;

&lt;p&gt;远程包的路径格式。远程包都有一个标准格式，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github.com/golang/go@v1.6.3

网站域名：代码托管的网站，如 github.com
作者或机构：这个项目的归属，如 golang
项目名： 这个项目的名字，如 go
版本号： 默认拉取最新版本，所以也可以用于更新库文件，如果要指定版本，则格式为 @v+本版号，如 @v1.6.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mod 开启时，go get 的下载路径为 $GOPATH/pkg/mod, 当 mod 关闭时，go get 的下载路径为 $GOPATH/src。&lt;/p&gt;

&lt;h3 id=&#34;使用-2&#34;&gt;使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;packages 参数是必须的。也就是我们刚介绍的远程包的路径。如我们要拉去常用的 gin 框架，那么我们可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/gin-gonic/gin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls /home/edte/go/pkg/mod/github.com/gin-gonic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到 &lt;code&gt;gin@v1.6.3&lt;/code&gt;，则拉取成功。&lt;/p&gt;

&lt;p&gt;也可以指定版本号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/gin-gonic/gin@v1.6.2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ls /home/edte/go/pkg/mod/github.com/gin-gonic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到 &lt;code&gt;gin@v1.6.2&lt;/code&gt;和 &lt;code&gt;gin@v1.6.3&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果拉取过慢的话，可以自己设置好代理，或者使用官方的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果想要知道拉取的进度的话，可以使用 v 参数，v 是 ？的缩写。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go get -v github.com/gin-gonic/gin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就能看到进度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github.com/gin-gonic/gin/internal/bytesconv
github.com/gin-gonic/gin/internal/json
github.com/gin-gonic/gin/binding
github.com/gin-gonic/gin/render
github.com/gin-gonic/gin
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果我们只想下载而不编译安装，那么可以加上 d 参数，d 是 download 的缩写，比较容易理解。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -v -d github.com/gin-gonic/gin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls /home/edte/go/pkg/mod/github.com/gin-gonic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有 &lt;code&gt;gin@v1.6.3&lt;/code&gt; 则拉取成功，然后进入会发现并没有编译，但是直接使用 go get 拉取时也没有编译，故这里看不出区别，因为 gin 包是个没有可执行文件的项目，如果拉取那些有可执行文件的项目，使用 go get 才会编译。&lt;/p&gt;

&lt;h2 id=&#34;go-run&#34;&gt;go run&lt;/h2&gt;

&lt;h3 id=&#34;介绍-3&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;go run 编译并运行 main 包。go run 先编译 main 包下的 main 函数，然后运行这个文件。&lt;/p&gt;

&lt;p&gt;go run 没有产生可执行文件。使用 go build 命令时会在当前目录生成可执行文件，而使用 go run 没有生成可执行文件。如果想要知道编译的过程，我们知道 go 是传统的编程语言，有 编写-编译-链接-运行 这个过程，所以在编译的过程会产生临时文件，go build 就到链接，而 go run 则到运行。可以使用 work 参数，这个参数会输出临时目录的路径。&lt;/p&gt;

&lt;h3 id=&#34;使用-3&#34;&gt;使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;go run [build flags] [-exec xprog] package [arguments...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;package 参数是必须的，即是具体的入口函数所在的文件路径。我们举个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//main.go

package main

import &amp;quot;fmt&amp;quot;

func main() {
	fmt.Println(&amp;quot;Hello World&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;go run main.go&lt;/code&gt; 或 &lt;code&gt;go run /gee/main.go&lt;/code&gt; 会得到结果 &lt;code&gt;Hello World&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果要查看过程，则可以加上 v 参数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go run -v main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果要查看临时目录的路径，则加上 work 参数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go run -work main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WORK=/tmp/go-build409560032
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们会发现临时目录是 /tmp/go-buildxxx&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果需要使用命令行参数，那么直接在 package 后加上即可，即 arguments 参数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	fmt.Println(os.Args)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 os.Args 源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Args []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现 Args 是个 string 切片，第一个元素是文件的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go run main.go hhh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[/tmp/go-build246132840/b001/exe/main hhh]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;go-mod&#34;&gt;go mod&lt;/h2&gt;

&lt;h3 id=&#34;介绍-4&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;由于 go 的包管理早期非常糟糕，也比较复杂，这里只简单介绍一下早期其他的包管理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 1.5版本前，所以依赖包都放在 GOPATH 下，没有版本控制。如果两个项目依赖不同版本的包，这时候就容易出现兼容问题。为了解决这个问题，早期一般使用多个 GOPATH 来控制依赖，但对于那些相同的依赖管理也非常麻烦。而且多个 GOPATH 也比较让人头疼。&lt;/li&gt;
&lt;li&gt;1.5 版本推出了 vender 机制，所谓 vender 机制，也就是在每个项目都有一个 vender 目录，里面存放这个项目的依赖。go build 的时候先到 vender 目录查找依赖，没找到再到 GOPATH 下寻找依赖。这种方式依然让人不爽，一个项目有两个地方存放依赖，那么自然就会引出许多问题。&lt;/li&gt;
&lt;li&gt;1.11 版本推出了 modules 机制，即 go mod。mod 机制把所有依赖都放在 &lt;code&gt;$GOPATH/pkg/mod&lt;/code&gt; 目录下，里面可以存放着不同版本的依赖。然后在每个项目中都有一个 mod 文件，在这里设置使用的依赖类型和版本。这样迁移项目和管理依赖都方便许多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-4&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;首先打开 go mod 需要 设置 GO111MODUL 环境变量，不过最新现在已经默认开启。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;go mod help&lt;/code&gt; 查看一下 go mod 命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;download    download modules to local cache (下载依赖的module到本地cache))
edit        edit go.mod from tools or scripts (编辑go.mod文件)
graph       print module requirement graph (打印模块依赖图))
init        initialize new module in current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件))
tidy        add missing and remove unused modules (增加丢失的module，去掉未用的module)
vendor      make vendored copy of dependencies (将依赖复制到vendor下)
verify      verify dependencies have expected content (校验依赖)
why         explain why packages or modules are needed (解释为什么需要依赖)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来用实际例子讲解 go mod 的应用。&lt;/p&gt;

&lt;p&gt;我们现在知道 GOROOT 是 go 的安装目录，go 的标准库都放在这里。然后我们又知道 GOPATH 是工作目录，子目录 bin, pkg, src 都比较明确。所以建议项目的实际目录就放在 $GOPATH/src 下，这样每个目录的功能都很明显。但是 go mod 现在似乎只支持 $GOPATH/src 目录外，在这个目录仍然到 $GOPATH/src 而不是 $GOPATH/pkg/mod 下寻找依赖。不过实际上我使用也是支持 mod 的，也就是到 $GOPATH/pkg/mod 下寻找，原因我还没有找到。&lt;/p&gt;

&lt;p&gt;现在我们在 $GOPATH/src/ 下建立项目 gee&lt;/p&gt;

&lt;p&gt;然后使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go mod init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令初始化建立 go.mod 文件，现在就开启 mod 支持了。&lt;/p&gt;

&lt;p&gt;我们查看一下这个文件 &lt;code&gt;cat go.mod&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module gee

go 1.14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个我们容易理解，即 gee 模块，和 go 的版本。&lt;/p&gt;

&lt;p&gt;现在我们新建一个 main.go 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
└── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;

func main() {
	r := gin.Default()
	r.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了 gin 框架，当然现在是无法使用的，假设我们本地也没有这个库，现在我们需要 go build 或 go run 一下来激发 go mod机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go run main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们能够看到日志是在下载 gin 和相关的依赖，然后就 run 起来了。&lt;/p&gt;

&lt;p&gt;我们会发现多出了一个 go.sum 文件，cat 一下，发现是相关依赖和对于的 hash 值，平时也用不用管。&lt;/p&gt;

&lt;p&gt;现在我们查看一下这个库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls $GOPATH/pkg/mod/github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现 &lt;code&gt;gin-gonic&lt;/code&gt; 这个文件，说明 go mod 机制出发成功了。现在我们再来看一下 go.mod 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat go.mod
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;module wgwg

go 1.14

require (
    github.com/gin-gonic/gin v1.6.3
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到出现了一个  require 关键字。require 关键字即此项目的依赖列表。我们可以把 go.mod 文件删除，或者再新建一个项目，同样的使用 gin 框架，然后再 run 一下，我们会发现日志里没有再出现下载库的情况，说明 go mod 是先在本地查找依赖是否存在，如果不存在，再去拉取远程库。&lt;/p&gt;

&lt;p&gt;go mod tidy 命令会删除那些没有 import，但是 require 了的包。然后会把 import 了包放到 require 中，然后到 $GOPATH/pkg/mod 中检查这个包是否存在，如果存在，则导入这个包，如果不存在，则拉取这个包。所以这个命令可以用来清楚没有使用的依赖，导入依赖和批量拉取依赖。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果 go mod 中有些依赖我们没有使用，可以使用&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go mod tidy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令清除没有使用的依赖。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果我们使用了 go mod ，明明本地也有这个库，但是却无法使用，如在 goland 中 报红，我们同样可以使用&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go mod tidy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令，这个命令会去 $GOPATH/pkg/mod 路径查找。因为虽然使用了 go mod ，但是 go mod 并没有扫描 /pkg/mod 路径，不能获取本地库列表，如果使用 Goland 的话，新建 go mod 文件时，就有一个  Index 弹窗用于扫描目录。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果我们有些依赖本地没有，想要拉取，可以使用&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go mod tidy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令批量拉取。&lt;/p&gt;

&lt;p&gt;我日&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果我们需要拉取特定本版号的包，可以使用 go get 命令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果需要拉取所有依赖，可以使用 &lt;code&gt;go mod download&lt;/code&gt; 命令&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果拉取速度较慢，可以修改 GOPROXY 设置代理，具体可以看 go env。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在一些特殊情况，如没有网络，在本地迁移项目的话，可以把使用 vendor 代替 mod 机制，这样移动项目时直接把依赖移动走了。使用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;go mod vendor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令会在项目根目录新建 vendor 目录，会把依赖复制到这个目录。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果使用末个包，但是这个包改名了，这时候想要继续使用原来的包名，又要拉取最新的包。或者使用末个包，但是这个包在原来的地方下载不了，只能到其他地方下载，那么可以使用 replace 关键字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如 goland.org/x/text 包在国内无法下载，但是 github 上有备份，那么可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;replace 
	golang.org/x/text v0.3.0 =&amp;gt; github.com/golang/text v0.3.0
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到 github 拉取会当做 goland.org/x/text 包使用。&lt;/p&gt;

&lt;p&gt;更多的请看 &lt;a href=&#34;https://github.com/golang/go/wiki/Modules&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go mod wiki&lt;/a&gt; &lt;a href=&#34;https://learnku.com/docs/go-blog/using-go-modules/6485&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go blog 关于 mod 系列文章&lt;/a&gt; &lt;a href=&#34;https://learnku.com/go/t/33859&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一篇优秀的文章&lt;/a&gt; 等&lt;/p&gt;

&lt;h2 id=&#34;go-env&#34;&gt;go env&lt;/h2&gt;

&lt;p&gt;go env 命令用于查看和设置 go 环境变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go env [-json] [-u] [-w] [var ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认没有参数会以行模式输出所有环境变量，可以输入 &lt;code&gt;go env&lt;/code&gt; 查看，由又环境变量比较多，这里只介绍常用的几个。&lt;/p&gt;

&lt;p&gt;如果要查看具体的莫个或多个的环境变量，直接在 env 后加上即可，即 var 参数&lt;/p&gt;

&lt;p&gt;如 &lt;code&gt;go env GOPATH GOROOT&lt;/code&gt;，我的结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/edte/go
/usr/lib/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要输出 json 格式的结果，则加上 json 参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go env -json GOPATH GOROOT&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
        &amp;quot;GOPATH&amp;quot;: &amp;quot;/home/edte/go&amp;quot;,
        &amp;quot;GOROOT&amp;quot;: &amp;quot;/usr/lib/go&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要删除末个变量，则可以直接设为空字符，或者使用 u 参数，即 unset&lt;/p&gt;

&lt;p&gt;如 &lt;code&gt;go env -u GOBIN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果要更改末个变量，则需要使用 w 参数，即 write&lt;/p&gt;

&lt;p&gt;如 &lt;code&gt;go env -w GOPROXY=https://goproxy.io,direct&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是常见的环境变量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GOROOT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GOROOT 是刚安装 go 时会遇到的一个环境变量， GOROOT 用于存放 go 的安装路径，如标准库，工具链等就放在这个位置。一般安装 go 时会默认设置，从而无需手动设置，win 下一般在 &lt;code&gt;C:\go&lt;/code&gt;，可以使用 &lt;code&gt;go env GOROOT&lt;/code&gt;  查看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GOPATH&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GOPATH 也是安装 go 时会遇到的一个环境变量，用于存放工作目录。也就是实际工作时用到的目录，我们在 go install 中已经讲解了这个路径的具体作用。这个目录用于存放实际的项目源码以及用到的远程库文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GOBIN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GOBIN 是默认的一个环境变量，一般不用设置。我们在 go install 中说过，安装可执行程序时，会安装到 $GOPATH/bin 目录，这个目录就是 GOBIN ，我们也可以更改，不过一般不建议改。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GOOS 和 GOARCH&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;go 本身支持交叉编译，也就是可以在一个平台上生成另一个平台的可执行程序。因此需要设置目标操作系统和目标系统架构。GOOS 即 go os ，os 即操作系统，GOARCH 即 go arch，arch 即体系架构。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go env -json GOOS GOARCH  
{
        &amp;quot;GOARCH&amp;quot;: &amp;quot;amd64&amp;quot;,
        &amp;quot;GOOS&amp;quot;: &amp;quot;linux&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这两个值默认是本机的。如我们要生成 64 位的 win，使用 &lt;code&gt;go env -w GOOS=windows&lt;/code&gt; 设置 os，再使用 &lt;code&gt;go build main.go&lt;/code&gt; 就得到了 &lt;code&gt;main.exe&lt;/code&gt;,我们知道 exe 是 win 下可执行程序的后缀，故成功了。&lt;/p&gt;

&lt;p&gt;如果目标系统是 mac 或 linux ，可以使用 &lt;code&gt;uanme -a&lt;/code&gt; 查看，如果是 win ，直接看 32 位还是 64 位即可。&lt;/p&gt;

&lt;p&gt;下面是常用的&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;code&gt;$GOOS&lt;/code&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;code&gt;$GOARCH&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;386&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;amd64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;linux&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;386&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;linux&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;amd64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;linux&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;arm&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;linux&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;arm64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;GOPROXY&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 go mod 管理包拉取依赖时，包服务器一般在国外，拉取速度比较慢，一般我们可以自己设置代理，不过 go mod 官方自带了一个 代理方式，通过修改 GOPROXY 变量即可修改 go mod 拉取的代理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GO111MODULE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GO111MODULE 即 go1.11 版本推出的 go mod 机制。go mod 是最新的一种包管理工具。在 1.12 前 go mod 是默认关闭的，不过 1.13 后便默认开启了&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;状态&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;on&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;打开 go mod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;off&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;关闭 go mod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;auto&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;自动判断是否打开 go mod&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最新版一般都是默认打开的，建议不要修改。&lt;/p&gt;

&lt;h2 id=&#34;go-doc&#34;&gt;go doc&lt;/h2&gt;

&lt;p&gt;待续&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/b91c4400d4b2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.jikexueyuan.com/project/go-command-tutorial/0.5.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.flysnow.org/2017/03/09/go-in-action-go-doc.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go 中的标识符和关键字</title>
      <link>https://edte.github.io/2020/2020-05-31-go-%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-05-31-go-%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>

&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;

&lt;p&gt;关键字 (keyword) 也叫 保留字 (reserved word), 是编程语言中预先被定义，有特定意义的词。&lt;/p&gt;

&lt;p&gt;目前 go 中一共有 25 个关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标识符&#34;&gt;标识符&lt;/h2&gt;

&lt;p&gt;标识符  (identifier) 是用来识别物体的名称，即程序员自己取的名字，如变量名，类名，函数名，包名等可以更改的都是只能是标识符 。&lt;/p&gt;

&lt;h3 id=&#34;预定义标识符&#34;&gt;预定义标识符&lt;/h3&gt;

&lt;p&gt;预定义标识符即编程语言预先被定义的一些有特定意义的词，和关键字有些类似。&lt;/p&gt;

&lt;p&gt;目前 go 中有 36 个预定义标识符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;内建常量: true false iota nil
内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error
内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;空标识符&#34;&gt;空标识符&lt;/h3&gt;

&lt;p&gt;go 中的空标识符即 &lt;code&gt;_&lt;/code&gt;, 这是一个特殊的标识符。在 go 中，变量声明了就必须使用，在这种环境下就诞生了空标识符。&lt;/p&gt;

&lt;p&gt;空标识符会被编译器自动忽略，所以一般只能当做占位符使用。&lt;/p&gt;

&lt;p&gt;一般有这么几种使用情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在导包前使用，目的是只使用包中的 init 函数，而不使用该包中的其他变量或函数。如&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;函数有多个返回值，而只会使用到其中一些返回值，用于忽略其他返回值，如&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;for _, i := range &amp;quot;abc&amp;quot; {
	fmt.Println(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编译前检查某类型是否实现了某接口，在 go 中类型实现接口是自动的，我们难以判断是否实现了接口，这时候我们可以利用空白标识符来检查，当然，如果使用了一个优秀的 ide，那么编写的过程中便有提醒&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;type dog struct {
}

//func (d dog) sleep() {
//	panic(&amp;quot;implement me&amp;quot;)
//}

type animal interface {
	sleep()
}

// 如果 dog 实现了 animal 接口，那么可以赋值，否则会出错
var _ animal = dog{}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;预定义标识符和关键字的区别&#34;&gt;预定义标识符和关键字的区别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;标识符都是可以自定义修改的，而关键字无法修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以查看 标准库 builtin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bool is the set of boolean values, true and false.
type bool bool

// true and false are the two untyped boolean values.
const (
	true  = 0 == 0 // Untyped bool.
	false = 0 != 0 // Untyped bool.
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这些预定义标识符都是可以修改的，当然建议不要改&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关键字都有特定的使用语法，而预定义标识符则使用条件更宽泛&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，这是在 go 中，go 的关键字多是语句语法，而预定义标识符多是类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;标识符不能使用关键字，而可以使用预定义标识符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;标识符的命名&#34;&gt;标识符的命名&lt;/h3&gt;

&lt;p&gt;也就是 常量名，变量名，函数名，包名，文件名，目录名，项目名等，尤其是 变量的命名，是大多数程序员头疼的原因之一。关于标识符的合法命名和推荐命名规则详情可以查看 [这篇文章]()。&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;一门语言的特性几乎就由这些关键字和标识符所表示，后面的大多数知识点都是围绕这些展开的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>沟通的重要性</title>
      <link>https://edte.github.io/2020/2020-05-26-%E6%B2%9F%E9%80%9A%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Tue, 26 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://edte.github.io/2020/2020-05-26-%E6%B2%9F%E9%80%9A%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>

&lt;h2 id=&#34;沟通的重要性&#34;&gt;沟通的重要性&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;世界上大多数暴力都是因为沟通不到位造成的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;无论是技术人员，还是服务人员，每天总要花大量时间在与人沟通上。哪怕是再孤僻的人，他也无法离开社会独自生存，那他便总避免不了与人沟通。回忆我自己的人生，从出生，到学习，再到工作，我花费了大量时间在与家人，同学，同事，以及社会上的陌生人沟通上。仔细想来，许多时候我的行动和实际表达并不同步，甚至相反，有时我想要温柔一些，但是我的行动总是伤害着许多人。为什么会这样？&lt;/p&gt;

&lt;p&gt;回忆自己的过去，人们不知一次的强调要换位思考，有俗语道，屁股决定脑袋，也就是说人们的思考会受他的地位所限，也有许多人认为人是经验动物，人们无法理解没有经历过的事，无论事实如何，现实中我们常见的就是如此，人的共情能力和实际的经验决定了他是否能够理解他人，以及理解他人的程度，虽然经历都是不同的，但是我们却能够体会到相似的痛苦。正因为如此，如果人门不能够理解其他人经历过什么，或者正在经历什么，那么我们很可能做出违反我们意愿的事，一边爱着对方，而一边伤害着对方。&lt;/p&gt;

&lt;p&gt;正因为如此，要想和其他人沟通到位，需要理解对方的感情，理解对方的需求。人们也对此有一些经验，如换位思考，即自己处于对方，自己将有着怎样的感受，自己将怎样做；以及不思考对方的行为/语言，而思考对方的动机，比如莫天你的母亲打电话问你需不需要买厚衣服，你可以思考为什么她会说出这样的话，可能是你最近没有什么的精神，工作压力大，然后你母亲看在眼里，但她自动自己关心里会引起你的反感，所以看见冬天来临，问你需不需要买厚衣服，然后看你的反应什么的，当然你可以换位思考，如果你是孩子母亲，你孩子最近压力大，你们最近关系又不好，那你该怎么关心她呢？如这些就是相互理解的一些办法，为什么换位思考说着容易，但实际操作比较难呢，如我们说过的那样，因为人是经验动物，没有经历过的话，是无法理解的。没有实际当过父母，只是简单的用几句语言就能代入角色么，并没有那么容易，虽然我们思考“如果我是母亲。。”，但实际上母亲是什么？会经历什么？只是从文字角度“知道”而不“经历”，是“无法理解”的。上面都是从“我”的角度去推测对方的感受，实际上有个最简单的方法，是的，为什么对方不直接告诉我呢？这个最简单的办法在现实中却是最难办到的。而今天我们要讲的就是如何表达出自己的实际感受，以及如何理解对方的感受，从而相互理解进行沟通。&lt;/p&gt;

&lt;h2 id=&#34;非暴力沟通&#34;&gt;非暴力沟通&lt;/h2&gt;

&lt;p&gt;我们来讲一个比较常见的例子，这也是实际发生在我身上的事，那就是室友矛盾。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;高中的时候大家都只有一个目标，那就是考一个好大学，同学门之间的差距似乎都被相同的校服遮挡住了，可是随着进入了大学，同学们之间的差异就开始体现出来了。最近小张就很痛苦，他和室友们发生了一些矛盾，现在他们之间的关系越来越差，他并不是想把关系搞得多好，但是每天在寝室呆的时间比较长，压抑的气氛是让人很难受的。&lt;/p&gt;

&lt;p&gt;小张高中的时候比较刻苦，因此有一些精神衰弱，对睡眠声音要求比较高，但是室友则到了大学想要放松，每天会在熄灯后玩一段时间的游戏，小张因此睡眠不足，每天精神状态很差，但是又由于小张性格孤僻，不会与人沟通，多次尝试都以失败告终，最后以此为契机，之后小张与室友多次爆发一些矛盾，现在小张正在考虑搬出去住，但是他也知道延后的问题并不是被解决了，只会越来越严重。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;出现矛盾-&amp;gt;沟通不到位-&amp;gt;矛盾激化-&amp;gt;出现新的矛盾，这是一个典型的死循环，也许小张尝试过与室友沟通，但他可能多次言语却说不清楚问题所在，也可能根本没有意识到问题所在。现在为了解决这个问题，我们来了解一下非暴力沟通这种沟通方式。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;非暴力沟通&lt;/strong&gt;是一种能够使人们情意相通、互尊互爱、和谐相处的沟通方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是句废话，所谓的非暴力沟通就是沟通时把你的想法，你的感情，你的需求全部告诉对方，不要让对方再什么换位思考的瞎猜。&lt;/p&gt;

&lt;p&gt;下面是一般的要素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;事实+感情+需要+请求
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拿我们刚刚举的小张的例子来说&lt;/p&gt;

&lt;p&gt;事实：实际发生的事，不带有个人感情色彩。小张该说：你晚上在熄灯之后，在我睡觉之后仍然开声音玩游戏&lt;/p&gt;

&lt;p&gt;感情：对于这个事实，个人的感受是什么。是自己的感情，而不是对这件事的评论。如小张该说：我很痛苦，而不是说 你是个 SB&lt;/p&gt;

&lt;p&gt;需要：为什么会对这件事有这种感受，可能是价值观，期望，道德观等。如小张应该说：因为我精神衰弱，我想要睡觉&lt;/p&gt;

&lt;p&gt;请求：希望对方做出怎样实际的行动来满足自己的需要。如小张应该说：我希望你在熄灯后不玩游戏&lt;/p&gt;

&lt;p&gt;这并不是什么公式，但是一般需要把这几点说清楚，同时在沟通的过程中也可以加入其他的东西，如为什么自己会精神衰弱等等。这时对方也可能会说出他的问题，很大可能你没有发现对方也处于痛苦当中，对方也会给你提出条件，但这正是我们想要的。&lt;/p&gt;

&lt;p&gt;当然前提是对方能够交流，如果对方根本不可能交流，还是趁早离开对方比较好。&lt;/p&gt;

&lt;p&gt;为什么需要这几个要素呢，如果我们去掉其中的末个要素，你会发现它们经常发生在生活中。如果没有事实的话，很可能双方聊了半天，但是聊着聊着就扯到以前的矛盾中了，根本不可能解决现在的矛盾，而把以前的矛盾激化到现在来则是非常不理智的，尤其是夫妻之间。如果我们去掉感情的话，这经常发生在父母与子女之间，父母经常要你去做这件事，去做那件事，但唯独没有表达他的感情，虽然这种社会刻板印象让人们，尤其是长辈，几乎难以像子女表达感情，但这在子女来看，却单纯的表现为长辈对子女的控制和命令，而这会激起子女的逆反心理，通常都会以争吵结尾。同样的，如果没有表达清楚为什么需要对方这么做，也就是个人的需要，那么也很可能激起反弹，让对方认为是命令而反抗。而如果没有表达清楚请求，则更是常见，聊了半天，但是却没有把实际该做出怎样的行动表达出来，对方很可能做出错误的回应，而自己如果认为对方以此排挤自己，则更会激化矛盾了。这些都是比较常见的问题，下面我们来具体讲解一下这些要素，以及是什么造成人们间沟通的困难。&lt;/p&gt;

&lt;h2 id=&#34;不带评论的观察&#34;&gt;不带评论的观察&lt;/h2&gt;

&lt;h2 id=&#34;表达感情&#34;&gt;表达感情&lt;/h2&gt;

&lt;h2 id=&#34;情绪的根源&#34;&gt;情绪的根源&lt;/h2&gt;

&lt;h2 id=&#34;请求帮助&#34;&gt;请求帮助&lt;/h2&gt;

&lt;h2 id=&#34;逆反心理&#34;&gt;逆反心理&lt;/h2&gt;

&lt;p&gt;逆反心理是一种在沟通中常会出现的问题，为了更好的沟通，我们需要了解这种心理&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;逆反心理&lt;/strong&gt;在&lt;a href=&#34;https://wiki.mbalib.com/wiki/心理学&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;心理学&lt;/a&gt;上又叫控制心理，它是指行为主体按照特定的&lt;a href=&#34;https://wiki.mbalib.com/wiki/标准&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;标准&lt;/a&gt;或社会规范对人们进行引导和控制时，行为客体产生的反向心理活动。也可以说是人们由于受某种原因的影响而产生对某事物 (内容和形式) 持对立、抵触、反对态度的心理状态&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个人都拥有决定自己行为的自由，如果这种自由受到威胁，为了维护这种自由，我们就会反抗，这种行为就是逆反心理。在孩子的成长过程中，阅历的增长和父母间的冲突会导致矛盾放大，因此逆反心理会比较常见，也就是人们常说的叛逆期，但是实际上这种心理发生在各个年龄段中，不只是青少年期。&lt;/p&gt;

&lt;p&gt;什么会导致逆反心理？我们来举一个例子&lt;/p&gt;

&lt;p&gt;你的朋友经常吸烟，你怎么劝说他戒烟呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;吸烟的人都是没脑子家伙，有脑子的人都知道吸烟有害健康
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你这么说的话，可能会感受一下医院的网速。&lt;code&gt;没脑子的人&lt;/code&gt;这显然是对对方的嘲笑和批评，而这种话只会让问题严重&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;你爸说了，你必须停止吸烟
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你这么说的话，你们很可能并不是什么好朋友。&lt;code&gt;你必须&lt;/code&gt;这种命令式的语言显然和自由没有任何关系，如果你这么说的话，你是想练习一下争吵的技术吧&lt;/p&gt;

&lt;p&gt;那么怎么才是正确的选择呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“据世界卫生组织（WHO）统计，吸咽的人 60 岁以后患肺部疾病的比例为 74%，而不吸烟的人 60 岁以后患肺部疾病的比例仅为 4%。为了您的健康，请选择戒烟。”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;摆明事实，加上公正客观的分析，最后把选择的权利交给对方，还有什么比这更自由的吗？&lt;/p&gt;

&lt;p&gt;这种方法和我们今天讲的沟通方式已经契合了，你可以自己思考一下为什么&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/F5XvL8fnipNJkWz4yPVGSQ&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;心理逆反（Psychological Reactance）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://m.douban.com/book/subject/3533221/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;非暴力沟通&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>