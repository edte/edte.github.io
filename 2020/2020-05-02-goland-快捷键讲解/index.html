<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="edte">
  
  
  
  <link rel="prev" href="https://edte.github.io/2020/2020-05-01-%E6%B5%85%E8%B0%88-go-%E4%B8%AD%E7%9A%84-package-%E5%92%8C-directory/" />
  <link rel="next" href="https://edte.github.io/2020/2020-05-03-%E8%B0%88%E8%B0%88-golang-%E4%B8%AD%E6%8E%A5%E5%8F%A3-interface-%E7%9A%84%E5%BA%94%E7%94%A8/" />
  <link rel="canonical" href="https://edte.github.io/2020/2020-05-02-goland-%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B2%E8%A7%A3/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Goland 快捷键讲解 | a-simple-bolg
       
  </title>
  <meta name="title" content="Goland 快捷键讲解 | a-simple-bolg">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://edte.github.io/"
    },
    "articleSection" : "posts",
    "name" : "Goland 快捷键讲解",
    "headline" : "Goland 快捷键讲解",
    "description" : "原则 快捷键不能过多 快捷键不能过多，一个 ide 就有许多快捷键，再加上浏览器，终端等等，快捷键如此之多，而且快捷键与功能之间并没有关系，也就是说，你",
    "inLanguage" : "en-us",
    "author" : "edte",
    "creator" : "edte",
    "publisher": "edte",
    "accountablePerson" : "edte",
    "copyrightHolder" : "edte",
    "copyrightYear" : "2020",
    "datePublished": "2020-05-02 00:00:00 &#43;0000 UTC",
    "dateModified" : "2020-05-02 00:00:00 &#43;0000 UTC",
    "url" : "https://edte.github.io/2020/2020-05-02-goland-%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B2%E8%A7%A3/",
    "wordCount" : "5504",
    "keywords" : [  "a-simple-bolg"]
}
</script>

    <link href="//use.fontawesome.com/releases/v5.9.0/css/all.css" rel="stylesheet">
</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://edte.github.io/">a-simple-bolg</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://edte.github.io/">a-simple-bolg</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Goland 快捷键讲解</h1>
        <div class="post-meta">
           <i class="far fa-folder-open"></i>
                <span class="post-category">
                        <a href="https://edte.github.io/categories/goland/"> Goland </a>
                        
                </span>
          <span class="post-time">
         <i class="far fa-calendar-alt"></i>  <time datetime=2020-05-02 itemprop="datePublished">2020-05-02</time>
           </span>
         <i class="far fa-file-word"></i> <span class="post-word-count"> 5504 字</span>
         <i class="far fa-clock"></i> <span class="more-meta"> 11 分钟</span>
        </div>
    </header>
        
          <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#原则">原则</a>
<ul>
<li><a href="#快捷键不能过多">快捷键不能过多</a></li>
<li><a href="#不要只死记快捷键-要理解它的意义">不要只死记快捷键，要理解它的意义</a></li>
<li><a href="#使用工具帮助记忆">使用工具帮助记忆</a></li>
</ul></li>
<li><a href="#移动光标">移动光标</a>
<ul>
<li><a href="#基础">基础</a></li>
<li><a href="#跳转">跳转</a></li>
</ul></li>
<li><a href="#提示">提示</a></li>
<li><a href="#其他">其他</a></li>
<li><a href="#插件">插件</a></li>
<li><a href="#代码生成">代码生成</a>
<ul>
<li><a href="#最特殊的键-alt-enter">最特殊的键 alt+enter</a>
<ul>
<li><a href="#struct-相关">struct 相关</a></li>
<li><a href="#调用函数">调用函数</a></li>
<li><a href="#声明变量">声明变量</a></li>
<li><a href="#函数其他">函数其他</a></li>
<li><a href="#单词">单词</a></li>
<li><a href="#导包">导包</a></li>
<li><a href="#操作表达式的改变">操作表达式的改变</a></li>
</ul></li>
<li><a href="#生成测试代码-ctrl-shift-t">生成测试代码 Ctrl+Shift+T</a>
<ul>
<li><a href="#test-for-functions">Test for functions</a></li>
<li><a href="#test-for-files">Test for files</a></li>
<li><a href="#test-for-package">Test for package</a></li>
<li><a href="#empty-test-file">empty test file</a></li>
</ul></li>
<li><a href="#自动补全代码-ctrl-shfit-enter">自动补全代码  Ctrl+shfit+enter</a></li>
</ul></li>
<li><a href="#常用-action">常用 action</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
<script type="text/javascript">
  window.onload = function () {
    var fix = $('.post-toc');
    var end = $('.post-comment');
    var fixTop = fix.offset().top, fixHeight = fix.height();
    var endTop, miss;
    var offsetTop = fix[0].offsetTop;
    $(window).scroll(function () {
      var docTop = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
      if (end.length > 0) {
        endTop = end.offset().top;
        miss = endTop - docTop - fixHeight;
      }
      if (fixTop < docTop) {
        fix.css({ 'position': 'fixed' });
        if ((end.length > 0) && (endTop < (docTop + fixHeight))) {
          fix.css({ top: miss });
        } else {
          fix.css({ top: 0 });
        }
      } else {
        fix.css({ 'position': 'absolute' });
        fix.css({ top: offsetTop });
      }
    })
  }
</script> 

        

    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h2 id="原则">原则</h2>

<h3 id="快捷键不能过多">快捷键不能过多</h3>

<p>快捷键不能过多，一个 ide 就有许多快捷键，再加上浏览器，终端等等，快捷键如此之多，而且快捷键与功能之间并没有关系，也就是说，你只能靠大量练习形成肌肉记忆，这并不是一个高效的学习方式。</p>

<p>一般来说，对于一个应用来说，记忆 20，30 个都是很多的了，最主要的不是把快捷键记住，而是你要知道你在干什么，你要干什么。</p>

<h3 id="不要只死记快捷键-要理解它的意义">不要只死记快捷键，要理解它的意义</h3>

<p>比如我曾经无数次搜索 Goland 的快捷键表，可是最后记忆的还是那么几个，几乎没有增加，像什么 alt+shift，实现接口的 ctrl+i ，我看见过许多次，可是我仍然无法记住。</p>

<p>现在看来，这种方式就是错误的，不应该去“记忆”，而是要先理解它是什么意义，然后在用的时候会想到有这么一个功能，然后再去用。</p>

<h3 id="使用工具帮助记忆">使用工具帮助记忆</h3>

<p>自然我们会时常忘记对应的快捷键是什么，但这其实反而并不是太大的问题。为了解决这个问题，我们有两个方法。一就是写 cheat-list，要用的时候直接查，而就是使用搜索功能，直接搜索对应的快捷键。而在 Goland 中，搜索功能就是特殊的几个快捷键，如搜索 action, file, type 等。</p>

<p>这里扩展一下 i3 桌面，也是这么个道理，把多余的画面去掉，即可以强迫我们使用键盘，也能强迫我们使用搜索功能。无鼠标编程显然效率是灰常高的，当然也比时常要移动手去使用鼠标要舒适，还有  b 格加成。然后同时使用搜索功能也有几个好处。一是强化功能的印象，搜索时，其名字往往代表其功能，故在搜索时能表明知道自己在做什么，也能强化有这个功能的印象，许多功能并不是只有这个工具才有，这种强化思维也能迁移，会提高有意识提高效率的意识，会主动去寻找提高效率的方式，同时迁移工具时也会考虑这些。最后就是熟悉一下单词，比如我现在已经能熟练拼写 settings, plugins, keymap, background等等。。这能加大我们接触英语的可能性，因为这是我们主动的，而不是被动的。</p>

<ul>
<li>不要大幅度的修改初始快捷键</li>
</ul>

<p>自由度过高，大幅度的修改快捷键有一些坏处，如难以迁移，从迁移环境时比较麻烦，别人难以使用，有时会有牵一发而动全身的效果，改一个快捷键可能会造成后续大量的快捷键冲突，自定义的不符合人体工程学，上手成本过高等等。我曾经在 Goland 中使用 vim 插件，给 action 自定义了大量的快捷键，而且不同模式移动光标方法也不同，我使用的键盘也是可编程键盘，然后折腾了许久，最后对这一套我自己也不熟悉，编程效率直线下贱，而代码却未敲几行，甚至我还尝试过不同的键盘布局，最后我想到有时会使用其他环境而放弃了。总之，一切皆有度。</p>

<h2 id="移动光标">移动光标</h2>

<h3 id="基础">基础</h3>

<p><strong>上 下 左 右</strong></p>

<p><strong>移动到行首/尾</strong></p>

<p><strong>向上/下翻页</strong></p>

<p>这几个都是非常高频的键，但是如果是标准键位，使用这几个键都有大幅度的手部移动，这是非常难受的。我使用的是 66 布局，可以硬件编程。在 Space 左边有一个 fn 键，我的设置是</p>

<p>fn + h/j/k/l   左/下/上/右</p>

<p>fn + i/o        home/end</p>

<p>fn + ;  /        page up/ page down</p>

<p>左手大拇指按住 fn，右书按字母，这样不用移动手，习惯了后效率还是挺高的。</p>

<ul>
<li><strong>Ctrl+m</strong><br /></li>
</ul>

<p>这也是一个常用的键，有时候我们的写着写着，光标就到屏幕底部了，继续写时观看很不方便，这时我们就可以使用这个键，屏幕会滑动到光标所在处，即屏幕以光标为中心。</p>

<p>Ctrl+左/右   移动到上/下一个单词</p>

<p>Ctrl+home/end  移动到文件首/尾处</p>

<p>Ctrl+上/下   屏幕滑动但光标不动</p>

<h3 id="跳转">跳转</h3>

<ul>
<li>ctrl+B</li>
</ul>

<p>这是一个非常常用的键，使用这个会跳转到变量的定义处，如我们要查看某个函数的源码实现时，对着实例使用即可</p>

<ul>
<li>插件： acejump-lite</li>
</ul>

<p>当我们要在屏幕上跳转时，如光标在屏幕低，要跳转到屏幕顶某处，就可以使用这个插件，我自定义为 fn+m, 然后输入跳转的目标字符</p>

<ul>
<li>Ctrl+e</li>
</ul>

<p>这是一个非常常用的键</p>

<p>当我们要跳转到最近的文件时，可以使用这个键，然后移动到目标文件</p>

<p>当要跳转到某个文件时，也可以输入这个键，先使用这个键，然后输入文件名即可，这个类似使用 Ctrl+shift+N 查找文件</p>

<p>当我们要进入一些弹窗时，如要进入 run 窗口， terminal 窗口，enven log 窗口时，或者一些插件的窗口，如 translate 插件的 word book (生词本) 窗口，可以使用这个键再搜索名字</p>

<ul>
<li>Ctrl+Shift+A</li>
</ul>

<p>这也是一个非常常用的键，我们可以用这个键做许多事，这个键用来使用 action，action 是 goland 中许多操作都有的一个东西。</p>

<p>如我们要打开 设置，就可以使用键后，输入 settings 即可</p>

<p>如我们要打开 插件，输入 plugins, 要把主菜单关掉，可以输入 main ,第一个就是，或者我们要删除文件，可以对着文件输入 delete, 要新建文件，可以输入 go，要新建项目，可以输入 project ，要 运行代码，可以输入 run 等等，总之这个键可以代替大多数需要移动鼠标才能做的，要达到无鼠标编程，这个键需要熟练使用。</p>

<ul>
<li>Ctrl+ <sup>2</sup>&frasl;<sub>3</sub></li>
</ul>

<p>在编程中，我们经常会遇到 error，waring 等，我们想要检查文件有没有这些时，就可以使用这个键，在 goland 中原来的键是 F2/shift+F2, 即查询下/上一个 error，但是我键盘布局不方便，所以设置了一下</p>

<p>想提高程序健壮性，即检查 error, waing 等时，就可以使用这个键，在 goland 中一般 error 是红色下划线，警告是黄色下划线，还有其他的提示等，总之在提示处有值得改进的地方</p>

<p>想要快速跳转到 error 处，有时候我们要修改 error 时，使用 光标移动显然有些低效，这是我们可以直接用这个键，就可以直接跳转到 error 处</p>

<ul>
<li>ctrl+shfit</li>
</ul>

<p>返回刚打开的 tab</p>

<p>enter     新建下一行并移动到下一行, 改变此行</p>

<p>ctrl+enter 拆分此行，鼠标不动，在行尾使用，可新建下一行并鼠标不动</p>

<p>shift+enter  新建下一行并移动到下一行（不改变此行)</p>

<p>ctrl+alt+enter   新建上一行并到上一行</p>

<p>Ctrl+N       fing        type</p>

<p>Ctrl+Shift+N     查找 file
Ctrl+Alt+Shift+N    查找 func</p>

<p>Ctrl+[   跳转到函数大括号开始</p>

<p>Ctrl+]   跳转到函数大括号结束</p>

<h2 id="提示">提示</h2>

<ul>
<li>Ctrl+1    显示 error</li>
<li>Ctrl+p    显示参数  parameter info</li>
<li>Ctrl+Q   show documentation, 用来显示返回值比较方便</li>
</ul>

<h2 id="其他">其他</h2>

<ul>
<li>fn+s</li>
</ul>

<p>这三个设置为一个快捷键比较方便，我使用的是硬件编程，也可是试试 vim 插件，我还没有找到其他方法能够这样设置</p>

<p>Ctrl+Alt+L 格式化代码
Ctrl+Alt+O 优化导入的类和包
Ctrl+S     save</p>

<ul>
<li>Alt+1</li>
</ul>

<p>打开侧边栏</p>

<ul>
<li>Shift+F6<br /></li>
</ul>

<p>rename  所有的文件，类名，函数名，属性名都可以重命名，使用 Shift+F6  重命名，所有使用过这个名称的地方都会跟着改变</p>

<ul>
<li>Ctrl+R</li>
</ul>

<p>run</p>

<ul>
<li>Ctrl+w</li>
</ul>

<p>我们经常会修改代码，删除代码，那么就必然需要选中代码，这个快捷键就是用来选中代码的，连续使用会以此选中更多的代码。</p>

<p>比如我们要修改字符串</p>

<pre><code>fmt.Println(&quot;Sdfmsdf&quot;)
</code></pre>

<p>光标在 &ldquo;&rdquo;  中，那么我们使用一次 Ctrl+w 就会选中 &ldquo;&rdquo; 中的字符，就可以直接给修改或删除了，我们可以继续按，则会以此加上双引号，以此加上括号，以此选中整个语句。</p>

<p>如果我们要删除某个函数，可以对着函数名或直接在函数中多按几次 Ctrl+w, 就会选中整个函数代码块了，当然直接对着函数名按的次数少一些。</p>

<p>如果我们按快了，也可以按 Ctrl+shift+w 来撤销上一次选中。</p>

<p>Ctrl+/       行注释</p>

<p>Ctrl+shift+/  快注释</p>

<p>Ctrl+k    git add and commit
Ctrk+shift+k    git push</p>

<p>Ctrl+shift+space 智能提示</p>

<p>Ctrl+shift+f   find in path
Ctrl+shift+r   replace in path</p>

<p>Alt+j   选中相同的变量</p>

<p>Ctrl+shift+c   复制当前的文件的路径</p>

<p>Ctrl+d  重复当前行或选中文本</p>

<p>Ctrl+x 剪切当前行</p>

<p>Ctrl+c 双击复制当前行</p>

<p>Ctrl+y 删除当前行</p>

<p>ctrl+上：Clone Caret Above，多行选择</p>

<p>ctrl+下：Clone Caret Below</p>

<h2 id="插件">插件</h2>

<ul>
<li>translate 插件</li>
</ul>

<p>Ctrl+shift+y   取词翻译</p>

<p>Ctrl+shift+o   弹出翻译弹窗</p>

<ul>
<li>acejump-lite</li>
</ul>

<p>fn+m 字符跳转</p>

<h2 id="代码生成">代码生成</h2>

<h3 id="最特殊的键-alt-enter">最特殊的键 alt+enter</h3>

<p>此 action name 是 show context actions</p>

<p>这个键的作用可以在 Settings&gt;Editor&gt;Intensions&gt;go 中查看</p>

<p>最常用的几个就是 <code>struct 相关</code>和<code>调用函数</code>以及<code>add comment</code>了</p>

<h4 id="struct-相关">struct 相关</h4>

<ul>
<li>File all fields</li>
</ul>

<p>使用 struct 时，补全 其所有 fileds，只限于第一层，若 fileds 有 struct ，则不 fill 子 struct, 在 使用的 struct 里使用即可</p>

<p>Before</p>

<pre><code>type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Person{}
</code></pre>

<p>After</p>

<pre><code>type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Persona{
	Name:     &quot;&quot;,
	Location: Address{},
}
</code></pre>

<ul>
<li>File all fileds recursively</li>
</ul>

<p>使用 struct 时，补全 其所有 fileds，只限于第一层，若 fileds 有 struct ，则递归的 fill 所有 struct, 在 使用的 struct 里使用即可</p>

<p>Before</p>

<pre><code>type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Person{}
</code></pre>

<p>After</p>

<pre><code>type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Persona{
	Name: &quot;&quot;,
	Location: Address{
		Street: &quot;&quot;,
		City:   &quot;&quot;,
	},
}
</code></pre>

<ul>
<li>file fileds</li>
</ul>

<p>使用 struct， 选择一个 filed 补全， 在使用的 struct 里使用即可</p>

<p>Before</p>

<pre><code>type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Person{}
</code></pre>

<p>After</p>

<pre><code>type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Persona{
	Name:     &quot;&quot;,
}
</code></pre>

<ul>
<li>Generate constructor</li>
</ul>

<p>给 struct 生成 new 方法，在 struct 的声明处使用</p>

<p>Before</p>

<pre><code>type Person struct {
	name string
	age int
}
</code></pre>

<p>After</p>

<pre><code>type Person struct {
	name string
	age int
}

func NewPerson(name string, age int) *Person {
	return &amp;Person{name: name, age: age}
} 
</code></pre>

<ul>
<li>Generate getter</li>
</ul>

<p>给 struct filed 生成 getter 方法，在 struct 声明处，对着要生成的特定 file 即可</p>

<p>Before</p>

<pre><code>type Person struct {
	name string
}
</code></pre>

<p>After</p>

<pre><code>type Person struct {
	name string
}

func (p *Person) Name() string {
	return p.name
}
</code></pre>

<ul>
<li>Generate setter</li>
</ul>

<p>给 struct filed 生成 setter 方法，在 struct 声明处，对着要生成的特定 file 即可</p>

<p>Before</p>

<pre><code>type Person struct {
	name string
}
</code></pre>

<p>After</p>

<pre><code>type Person struct {
	name string
}

func (p *Person) SetName(name string) {
	p.name = name
}
</code></pre>

<ul>
<li>Generate getter and setter</li>
</ul>

<p>给 struct filed 生成 getter 和 setter 方法，在 struct 声明处，对着要生成的特定 file 即可</p>

<p>Before</p>

<pre><code>type Person struct {
	name string
}
</code></pre>

<p>After</p>

<pre><code>type Person struct {
	name string
}

func (p *Person) Name() string {
	return p.name
}

func (p *Person) SetName(name string) {
	p.name = name
}
</code></pre>

<ul>
<li>Implement interface</li>
</ul>

<p>给结构体实现某接口，接口可以是自定义的，也可以是已有的。也就是给结构体生成接口含有的所有方法。这个功能有快捷键 Ctrl+i, 对着结构体的声明处使用即可</p>

<p>Before</p>

<pre><code>package main

type A struct {}

type B interface {
	a1() int
	a2() int
	a3() int
}
</code></pre>

<p>After</p>

<pre><code>package main

type A struct {}

func (*A) a1() int {
	panic(&quot;implement me&quot;)
}

func (*A) a2() int {
	panic(&quot;implement me&quot;)
}

func (*A) a3() int {
	panic(&quot;implement me&quot;)
}

type B interface {
	a1() int
	a2() int
	a3() int
}
</code></pre>

<ul>
<li>Move field assignment to struct initialization</li>
</ul>

<p>使用了一个 struct, 然后又写了一个赋值语句，这个命令是把两个语句合成一个语句，在 初始化语句里使用即可</p>

<p>Before</p>

<pre><code>s := S{}
s.foo = `bar`
</code></pre>

<p>After</p>

<pre><code>s := S{foo: `bar`}
</code></pre>

<ul>
<li>Remove keys from struct literal</li>
</ul>

<p>使用 struct 时，把 filed name 去掉，在使用 struct 时使用</p>

<p>Before</p>

<pre><code>var _ = struct{int; string; slice []int}{string : &quot;a&quot;, int : 2}
</code></pre>

<p>After</p>

<pre><code>var _ = struct{int; string; slice []int}{2, &quot;a&quot;, nil}
</code></pre>

<h4 id="调用函数">调用函数</h4>

<ul>
<li>ignore explicitly</li>
</ul>

<p>调用函数时，有时函数会报黄，会出现这个选项，这个选项有点类似 Introduce to local variable ， 不过后者是快速生成返回值，这个则是用 <code>_</code> 占位符表示返回值</p>

<p>before</p>

<pre><code>ioutil.WriteFile()
</code></pre>

<p>After</p>

<pre><code>_ = ioutil.WriteFile()
</code></pre>

<ul>
<li>do not report this method/function anymore</li>
</ul>

<p>调用函数时，有时函数会报黄，会出现这个选项, 使用这个后这个函数班会再变黄，至于为什么会变黄，我猜是 warning, 具体原因暂时未知</p>

<ul>
<li>Introduce to local variable</li>
</ul>

<p>调用函数时，迅速生成赋值返回值变量，对着调用的函数名使用</p>

<p>Before</p>

<pre><code>func Add(a int, b int) int {
	return a + b
}
func main() {
	Add(1, 2)
}
</code></pre>

<p>After</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	add, err := Add(1, 2)
}
</code></pre>

<ul>
<li>Rename _</li>
</ul>

<p>调用函数后，把没有使用的赋值变量变为 _ , 对着没有使用的变量使用即可</p>

<p>Before</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a, err := Add(1, 2)
}
</code></pre>

<p>After</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	_, err := Add(1, 2)
}
</code></pre>

<ul>
<li>Insert bank identifies to left side of assginment statement</li>
</ul>

<p>调用函数时，若有多个返回值，而赋值的变量没有返回值多，那么对着变量使用后，会自动补全返回值个数</p>

<p>Before</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a := Add(1, 2)
}
</code></pre>

<p>After</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a, _ := Add(1, 2)
}
</code></pre>

<ul>
<li>Replace with &ldquo;:&rdquo;</li>
</ul>

<p>调用函数时，若赋值的变量没有声明，那么对其使用就会直接声明后赋值</p>

<p>Before</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a = Add(1, 2)
}
</code></pre>

<p>AAfter</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a := Add(1, 2)
}
</code></pre>

<ul>
<li>Add missing return values</li>
</ul>

<p>函数 return 返回值时，若个数不够，那么在 return 使用会自动增加返回值</p>

<p>Before</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b
}
</code></pre>

<p>After</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}
</code></pre>

<ul>
<li>Remove 2nd result parameter from function</li>
</ul>

<p>函数 return 返回值时，若个数不够, 或者调用函数时，赋值的变量比返回值少，使用后会把返回值减少到对应个数</p>

<p>Before</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b, nil
}

func main() {
	a := Add(1, 2)
}
</code></pre>

<p>After</p>

<pre><code>func Add(a int, b int) int {
	return a + b
}

func main() {
	a := Add(1, 2)
}
</code></pre>

<p>或者</p>

<p>Before</p>

<pre><code>func Add(a int, b int) (int, error) {
	return a + b
}
</code></pre>

<p>After</p>

<pre><code>func Add(a int, b int) int {
	return a + b
}
</code></pre>

<h4 id="声明变量">声明变量</h4>

<ul>
<li>Add parens to declaration</li>
</ul>

<p>给单个变量声明时添加括号，在变量声明处使用</p>

<p>Before</p>

<pre><code>var a string
</code></pre>

<p>After</p>

<pre><code>var (
	a string
)
</code></pre>

<blockquote>
<p>这里说一下 import 时的情况，在 goland 中，只 import 了一个package，要加括号的话在 import 后直接打 ( 即可，goland 会自动把其放入括号中</p>
</blockquote>

<ul>
<li>Remove parens from declaration</li>
</ul>

<p>与 Add parens to delartion 相反，去除括号</p>

<p>Before</p>

<pre><code>var (
	a string
)
</code></pre>

<p>After</p>

<pre><code>var a string
</code></pre>

<ul>
<li>Merge all declaration</li>
</ul>

<p>给连续三个以上的变量声明划分为一组，空格隔开的不算，对着变量使用即可</p>

<p>Before</p>

<pre><code>var a string

var b int
var c float32
var d bool

var e int
</code></pre>

<p>After</p>

<pre><code>var a string

var (
	b int
	c float32
	d bool
)

var e int
</code></pre>

<ul>
<li>split all declaration</li>
</ul>

<p>与  Merge all declaration 相反，会把括号里的变量分开声明</p>

<p>Before</p>

<pre><code>var (
	a string
	b int
	c int
)
</code></pre>

<p>After</p>

<pre><code>var a string
var b int
var c int
</code></pre>

<ul>
<li>merge declaration up</li>
</ul>

<p>把这个变量和上一个声明的变量放在一个括号中，空格不影响</p>

<p>Before</p>

<pre><code>var a string
var b int
</code></pre>

<p>After</p>

<pre><code>var (
	a string
	b int
)
</code></pre>

<ul>
<li>merge declaration up via comma</li>
</ul>

<p>把这个变量和上一个声明的变量放在一行，空格不影响</p>

<p>Before</p>

<pre><code>var a int
var b int
</code></pre>

<p>After</p>

<pre><code>var a, b int
</code></pre>

<ul>
<li>split declaration by comma</li>
</ul>

<p>于 merge declaration up via comma 相反，把一行声明的变量变为多行声明</p>

<p>Before</p>

<pre><code>var a, b int
</code></pre>

<p>After</p>

<pre><code>var a int
var b int
</code></pre>

<ul>
<li>convert to short var declaration</li>
</ul>

<p>把 var 变量的声明格式变为更短的  :=  格式，在 var 变量声明处使用</p>

<p>Before</p>

<pre><code>var x = 1
</code></pre>

<p>After</p>

<pre><code>x := 1
</code></pre>

<ul>
<li>convert to var declaration</li>
</ul>

<p>与 convert to short var declaration 相反，把 := 声明的变量变为 var 声明的格式，在 := 变量声明处使用</p>

<p>Before</p>

<pre><code>x := 1
</code></pre>

<p>After</p>

<pre><code>var x = 1
</code></pre>

<h4 id="函数其他">函数其他</h4>

<ul>
<li>Add comment</li>
</ul>

<p>在声明函数的地方，对着函数名可以生成此函数的注释</p>

<p>Before</p>

<pre><code>package foo

func Foo() {

}
</code></pre>

<p>After</p>

<pre><code>package foo

// Foo 
func Foo() {

}
</code></pre>

<ul>
<li>add format string argument</li>
</ul>

<p>在支持格式化的函数的参数里， 即 (&ldquo;&rdquo;) 的引号中使用。选择一个变量后，会自动生成相应的格式化输出。</p>

<p>如 int 类型 a, 输入 a 后会自动生成 %d, 而无需记忆对应的意义。</p>

<p>Before</p>

<pre><code>func log(count int) {
	fmt.Printf(`count is: `)
}
</code></pre>

<p>After</p>

<pre><code>func log(count int) {
	fmt.Printf(`count is: %d`, count)
}
</code></pre>

<ul>
<li>Expand signature types</li>
</ul>

<p>在参数和返回值时，转换类型的写法, 在参数或返回值括号内使用即可</p>

<p>Before</p>

<pre><code>func foo(s1, s2 string) (i1, i2 int) {
	return 0, 1
}
</code></pre>

<p>After</p>

<pre><code>func foo(s1 string, s2 string) (i1 int, i2 int) {
	return 0, 1
}
</code></pre>

<ul>
<li>Reuse signature types</li>
</ul>

<p>与上面的 Expand signature types 相反</p>

<p>Before</p>

<pre><code>func bar(s1 string, s2 string) (i1 int, i2 int) {
	return 0, 1
}
</code></pre>

<p>After</p>

<pre><code>func bar(s1, s2 string) (i1, i2 int) {
	return 0, 1
}
</code></pre>

<ul>
<li>Export</li>
</ul>

<p>把私有 func, type, filed 变为公有的，在 func或 type 或 sturct 里的 filed 里使用即可</p>

<p>Before</p>

<pre><code>func private() {}
</code></pre>

<p>After</p>

<pre><code>func Private() {}
</code></pre>

<ul>
<li>Invert if</li>
</ul>

<p>把 if- else 语句反过来，在 操作符 处使用即可</p>

<p>Before</p>

<pre><code>a := 1
if a &gt;= 2 {
	fmt.Println(&quot;a &gt;= 2&quot;)
} else {
	fmt.Println(&quot;a &lt; 2&quot;)
}
</code></pre>

<p>After</p>

<pre><code>a := 1
if a &lt; 2 {
	fmt.Println(&quot;a &lt; 2&quot;)
} else {
	fmt.Println(&quot;a &gt;= 2&quot;)
}
</code></pre>

<h4 id="单词">单词</h4>

<ul>
<li>typo change to</li>
</ul>

<p>对着拼错的单词使用，在对标识符命名，写注释什么的很方便</p>

<p>Before</p>

<pre><code>blak
</code></pre>

<p>After</p>

<pre><code>black
</code></pre>

<h4 id="导包">导包</h4>

<ul>
<li>sync dependencies of</li>
</ul>

<p>在 import 后添加想要拉的包 path, 任何使用这个 action, 可以直接拉包，类似 go get。</p>

<ul>
<li>Add dot import alias</li>
</ul>

<p>在导的包前或使用的包名中使用，可以直接用包里的函数</p>

<p>Before</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello World!&quot;)
}
</code></pre>

<p>After</p>

<pre><code>package main

import . &quot;fmt&quot;

func main() {
    Println(&quot;Hello World!&quot;)
}
</code></pre>

<ul>
<li>Remove dot import alias</li>
</ul>

<p>和 Add dot import alias 相反，取消其效果，导的包前或使用的包名中使用</p>

<p>Before</p>

<pre><code>package main

import . &quot;fmt&quot;

func main() {
    Println(&quot;Hello World!&quot;)
}
</code></pre>

<p>After</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello World!&quot;)
}
</code></pre>

<ul>
<li>Add import alias</li>
</ul>

<p>这个同样在导的包前或使用的包名中使用，可以给包设置别名</p>

<p>Before</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello World!&quot;)
}
</code></pre>

<p>After</p>

<pre><code>package main

import fmtAlias &quot;fmt&quot;

func main() {
    fmtAlias.Println(&quot;Hello World!&quot;)
}
</code></pre>

<h4 id="操作表达式的改变">操作表达式的改变</h4>

<ul>
<li>flip binary operator</li>
<li>negate expression</li>
<li>negate expression recurisively</li>
<li>negate topmostexpression</li>
<li>negate topmostexpression recurisively</li>
</ul>

<p>这几个都是不常用的（至少我没怎么用到)</p>

<h3 id="生成测试代码-ctrl-shift-t">生成测试代码 Ctrl+Shift+T</h3>

<p>此 action name 是 go to  test</p>

<p>这个键一共有 4 个功能</p>

<h4 id="test-for-functions">Test for functions</h4>

<p>这个是最常用的，在函数内使用即可。</p>

<p>这个功能是生成函数测试。</p>

<p>go 中的测试文件需要在原有文件名后加上 _test, 测试函数需要在函数名前加上 Test ,参数也是特殊的。</p>

<p>如果手动生成的话比较麻烦且容易忘记，于是可以使用此快捷键。</p>

<p>如：</p>

<p>Before</p>

<pre><code>db.go 中

func Hello {
	fmt.Println(&quot;Hello World&quot;)
}
</code></pre>

<p>After</p>

<pre><code>生成 db_test.go 文件
其中 
func TestHello(t *testing.T) {
//...
}
</code></pre>

<h4 id="test-for-files">Test for files</h4>

<p>生成此 files 内的所有函数的 test</p>

<h4 id="test-for-package">Test for package</h4>

<p>生成此 package 内的所有函数的 test</p>

<h4 id="empty-test-file">empty test file</h4>

<p>生成空 test file, 里面没有 TestFunc</p>

<h3 id="自动补全代码-ctrl-shfit-enter">自动补全代码  Ctrl+shfit+enter</h3>

<ul>
<li>自动补全右括号</li>
</ul>

<p>有时候要把莫东西加到括号中，可以先加上左括号，然后对着此行使用，会自动补全右括号并移动到下一行</p>

<p>Before</p>

<pre><code>func main() {
	fmt.Println (&quot;Hello World!&quot;
}
</code></pre>

<p>After</p>

<pre><code>func main() {
	fmt.Println(&quot;Hello Wrold!&quot;)
}
</code></pre>

<ul>
<li>自动补全大括号</li>
</ul>

<p>有时候大括号多了，会不小心删除右括号，这时候使用会自动生成右括号</p>

<p>Before</p>

<pre><code>func main(){
	fmt.Println(&quot;hello World!&quot;)

</code></pre>

<p>After</p>

<pre><code>func main() {
	fmt.Println(&quot;hello world!&quot;)
}
</code></pre>

<h2 id="常用-action">常用 action</h2>

<ul>
<li>find usage 查找方法被调用的地方</li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>edte </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://edte.github.io/2020/2020-05-02-goland-%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B2%E8%A7%A3/>https://edte.github.io/2020/2020-05-02-goland-%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B2%E8%A7%A3/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://edte.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://edte.github.io/2020/2020-05-01-%E6%B5%85%E8%B0%88-go-%E4%B8%AD%E7%9A%84-package-%E5%92%8C-directory/" class="prev" rel="prev" title="浅谈 go 中的 package 和 directory"><i class="iconfont icon-left"></i>&nbsp;浅谈 go 中的 package 和 directory</a>
         
        
        <a href="https://edte.github.io/2020/2020-05-03-%E8%B0%88%E8%B0%88-golang-%E4%B8%AD%E6%8E%A5%E5%8F%A3-interface-%E7%9A%84%E5%BA%94%E7%94%A8/" class="next" rel="next" title="谈谈 Golang 中接口 interface 的应用">谈谈 Golang 中接口 interface 的应用&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

 <div class="post-comment">
       
             
             
             <span id="/2020/2020-05-02-goland-%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B2%E8%A7%A3/" class="leancloud_visitors" data-flag-title="Goland 快捷键讲解">
                 <span class="post-meta-item-text">访问量 </span>
                 <span class="leancloud-visitors-count"></span>
                 <p></p>
             </span>
             <div id="vcomments"></div>
             <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
             <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
             <script type="text/javascript">
                 new Valine({
                     el: '#vcomments' ,
                     appId: 'jYOoQf1fiqM8W9yLLQFElx0b-MdYXbMMI',
                     appKey: 'kBEzPfUjNEJ4MSrSRitotLRX',
                     notify:  false ,
                     verify:  false ,
                     avatar:'mp',
                     placeholder: '说点什么吧...',
                     visitor:  true 
                 });
             </script>
       
 </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2020 - 2022</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://edte.github.io/">edte</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
